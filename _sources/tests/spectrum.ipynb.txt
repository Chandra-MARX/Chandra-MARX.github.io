{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "51585940",
   "metadata": {},
   "source": [
    "# Reproducing an input spectrum\n",
    "marx allows users to specify either a flat input spectrum or to pass in a file.\n",
    "Here, we generate input spectra with the spectral modeling program [Sherpa](https://cxc.cfa.harvard.edu/sherpa/).\n",
    "We run marx to\n",
    "simulate a point source and extract the data from that simulation using [CIAO](https://cxc.cfa.harvard.edu/ciao/),\n",
    "read it back into [Sherpa](https://cxc.cfa.harvard.edu/sherpa/) and fit the simulated data.\n",
    "If everything works well and all detector effects are treated consistently,\n",
    "we should recover the same spectral parameters (up to Poisson noise).\n",
    "On the other hand, if marx and\n",
    "`CIAO`_ are inconsistent the fit parameters will deviate from the input\n",
    "parameters.\n",
    "\n",
    "In the past, this has happened after the release of marx 5.0, which contains\n",
    "some files to describe the ACIS contamination. This contamination changes with\n",
    "time and several CalDB releases had happened before we released marx 5.1.\n",
    "At that time, marx always predicted too many counts at low energies.\n",
    "\n",
    "The following tests are designed to test **consistency** with CIAO.\n",
    "Since there is always some uncertainty about the intrinsic spectrum of\n",
    "astrophysical sources, this test is best done with simulated input spectra."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1256993f",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Load marx in local environment and set up pfiles for tests\n",
    "from utils import setup_marx\n",
    "setup_marx()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8c24b93f",
   "metadata": {},
   "source": [
    "## Absorbed powerlaw on ACIS-S\n",
    "This test checks the internal consistency of a marx spectral simulation\n",
    "by simulating a source placed on a back-illuminated chip of ACIS-S.\n",
    "The input spectrum is an absorbed powerlaw."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "744f4aea",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Set up a Sherpa model and use that to generate an spectrum as input for Marx.'''\n",
    "\n",
    "import numpy as np\n",
    "from sherpa.astro import ui\n",
    "\n",
    "ui.set_source(1, ui.xsphabs.a * ui.xspowerlaw.p)\n",
    "a.nH = 1.0\n",
    "p.PhoIndex = 1.8\n",
    "p.norm = 0.001\n",
    "\n",
    "# get source\n",
    "my_src = ui.get_source()\n",
    "\n",
    "# set energy grid\n",
    "bin_width = 0.01\n",
    "energies = np.arange(0.15, 12., bin_width)\n",
    "\n",
    "# evaluate source on energy grid\n",
    "flux = my_src(energies[:-1], energies[1:])\n",
    "\n",
    "ui.save_arrays(\"marx_input.tbl\", [energies[1:], flux / bin_width], \n",
    "               [\"keV\",\"photons/s/cm**2/keV\"], ascii=True, clobber=True)\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8c159348",
   "metadata": {},
   "outputs": [],
   "source": [
    "import subprocess\n",
    "\n",
    "out = subprocess.run('marx SourceFlux=-1 SpectrumType=FILE SpectrumFile=marx_input.tbl ExposureTime=30000 ' + \n",
    "                     'TStart=2015.5 OutputDir=marx GratingType=NONE DetectorType=ACIS-S DitherModel=INTERNAL ' +\n",
    "                     'RA_Nom=30 Dec_Nom=40 SourceRA=30 SourceDEC=40', shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx marx_evt2.fits', shell=True, capture_output=True)\n",
    "out3 = subprocess.run('marxasp MarxDir=marx OutputFile=marx_asol1.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a9dcdc0f",
   "metadata": {},
   "source": [
    "We generate an input spectrum and run marx. We then extract the spectrum in two different ways:\n",
    "1. We use CIAO tools, but specify special qualifiers to account for the fact that marx does not include ACIS QE maps and uses FEF rmfs (FEF's are parameterized functions to describe the shape of the RMF. They are faster to compute, but not as accurate as the tabulated values usually used in CIAO). We do that by setting the detector name to `\"ACIS-7;UNIFORM;bpmask=0\"` in [mkarf](https://cxc.cfa.harvard.edu/ciao/ahelp/mkarf.html) and by passing the appropriate FEF to [mkrmf](https://cxc.cfa.harvard.edu/ciao/ahelp/mkrmf.html).\n",
    "2. We use the [specextract tool](https://cxc.cfa.harvard.edu/ciao/ahelp/specextract.html) without any special qualifiers. While `specextract` has a number of parameters, it does not allow us to set the dectector or force the use of an FEF file. It requires only a call to a single tool, but is inconsistent with the simulations done by marx, so fitted spectra will not match the input parameters as well as in method 1."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4c790856",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Extract spectra\n",
    "\n",
    "Use special settings to account for steps that |marx| does not include:\n",
    "ACIS QE maps and current (non FEF) rmfs.\n",
    "\n",
    "We warp this into a function because we are going to use the same steps\n",
    "for more examples further down in the notebook and thus would be a fairly long\n",
    "piece of code to copy and paste.\n",
    "'''\n",
    "import os\n",
    "\n",
    "import ciao_contrib.runtool as rt\n",
    "from coords.chandra import sky_to_chandra\n",
    "from astropy.io import fits\n",
    "\n",
    "def special_extraction(x, y, radius):\n",
    "    phagrid=\"pi=1:1024:1\"\n",
    "\n",
    "    evtfile=\"marx_evt2.fits\"\n",
    "    asolfile=\"marx_asol1.fits\"\n",
    "    phafile=\"marx_pha.fits\"\n",
    "    rmffile=\"marx_rmf.fits\"\n",
    "    arffile=\"marx_arf.fits\"\n",
    "    asphistfile=\"marx_asp.fits\"\n",
    "\n",
    "    rt.asphist(infile=asolfile, outfile=asphistfile, evtfile=evtfile, clobber=True)\n",
    "\n",
    "    rt.dmextract(infile=f\"{evtfile}[sky=circle({x},{y},{radius})][bin {phagrid}]\", \n",
    "                outfile=phafile, clobber=True)\n",
    "    coos = sky_to_chandra(fits.getheader(evtfile, 1), x, y)\n",
    "    ccdid = coos['chip_id'][0]\n",
    "    chipx = coos['chipx'][0]\n",
    "    chipy = coos['chipy'][0]\n",
    "\n",
    "    detname=f\"ACIS-{ccdid};UNIFORM;bpmask=0\"\n",
    "    # For ACIS-I, use engrid=\"0.3:11.0:0.003\". This reflects a limitation of mkrmf.\n",
    "    engrid=\"0.3:12.0:0.003\"\n",
    "\n",
    "    rt.mkarf(mirror=\"hrma\", detsubsys=detname, grating=\"NONE\",\n",
    "    outfile=arffile, obsfile=evtfile, engrid=engrid, asphistfile=asphistfile,\n",
    "    sourcepixelx=x, sourcepixely=y, maskfile=\"NONE\", pbkfile=\"NONE\", dafile=\"NONE\", clobber=True, verbose=0)\n",
    "\n",
    "    fef=os.environ['CALDB'] + \"/data/chandra/acis/fef_pha/acisD2000-01-29fef_phaN0005.fits\"\n",
    "\n",
    "    cxfilter=f\"chipx_hi>={chipx},chipx_lo<={chipx}\"\n",
    "    cyfilter=f\"chipy_hi>={chipy},chipy_lo<={chipy}\"\n",
    "    rt.mkrmf(infile=f\"{fef}[ccd_id={ccdid},{cxfilter},{cyfilter}]\", outfile=rmffile,\n",
    "            axis1=f\"energy={engrid}\", axis2=phagrid, thresh=1e-8, clobber=True, verbose=0)\n",
    "    \n",
    "special_extraction(4096.4, 4096.4, 20.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f853cc48",
   "metadata": {},
   "outputs": [],
   "source": [
    "from sherpa.utils.logging import SherpaVerbosity\n",
    "# Only display error messages, but hide other output from specextract\n",
    "with SherpaVerbosity('ERROR'):\n",
    "    rt.specextract(f\"marx_evt2.fits[sky=circle(4096.5,4096.5,20)]\", \"spec\", asp=\"marx_asp.fits\", weight=False,\n",
    "                clobber=True, mskfile=\"NONE\", badpixfile=\"NONE\")\n",
    "       \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fb9d6ed2",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.load_pha(\"special extraction\", 'marx_pha.fits')\n",
    "    ui.load_rmf(\"special extraction\", 'marx_rmf.fits')\n",
    "    ui.load_arf(\"special extraction\", 'marx_arf.fits')\n",
    "    ui.load_data(\"specextract\", 'spec_grp.pi')\n",
    "    ui.group_counts(\"special extraction\", 25)\n",
    "    ui.group_counts(\"specextract\", 25)\n",
    "    ui.ignore(None, 0.3)\n",
    "    ui.ignore(7, None)\n",
    "    # set source properties\n",
    "    ui.set_source(\"special extraction\", ui.xsphabs.a1 * ui.xspowerlaw.p1)\n",
    "    ui.set_source(\"specextract\", ui.xsphabs.a2 * ui.xspowerlaw.p2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4ed0fd8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"special extraction\")\n",
    "    ui.conf(\"special extraction\")\n",
    "    conf_special = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7e27cda6",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"specextract\")\n",
    "    ui.conf(\"specextract\")\n",
    "    conf_specextract = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bed065c3",
   "metadata": {},
   "outputs": [],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# Better setting to display labels on a log axis\n",
    "import matplotlib as mpl\n",
    "mpl.rcParams['axes.formatter.min_exponent'] = 2\n",
    "\n",
    "a1 = ui.get_arf(\"special extraction\")\n",
    "a2 = ui.get_arf(\"specextract\")\n",
    "# bring on same energy grid\n",
    "engrid = np.arange(0.3, 10., 0.05)\n",
    "a1 = np.interp(engrid, 0.5 * (a1.energ_lo + a1.energ_hi), a1.get_y())\n",
    "a2 = np.interp(engrid, 0.5 * (a2.energ_lo + a2.energ_hi) , a2.get_y())\n",
    "\n",
    "\n",
    "fig, axes = plt.subplots(2, 1, sharex=True, figsize=(8, 6))\n",
    "plt.sca(axes[0])\n",
    "ui.plot_data(\"special extraction\", xlog=True, ylog=True, clearwindow=False)\n",
    "ui.plot_model(\"special extraction\", overplot=True, label=\"special extraction\")\n",
    "ui.plot_model(\"specextract\", overplot=True, label=\"specextract\")\n",
    "axes[0].legend()\n",
    "axes[0].set_title(\"Simulated data with fits using different ARFs and RMFs\")\n",
    "\n",
    "axes[1].loglog(engrid, a1, label=\"special extraction\", c=\"C1\")\n",
    "axes[1].loglog(engrid, a2, label=\"specextract\", c=\"C2\")\n",
    "axes[1].set_xlabel(\"Energy (keV)\")\n",
    "axes[1].set_ylabel(\"Effective Area (cm$^2$)\")\n",
    "axes[1].legend()\n",
    "\n",
    "# Better setting to display labels on a log axis\n",
    "axes[1].get_xaxis().set_minor_formatter(mpl.ticker.LogFormatterMathtext(labelOnlyBase=False,\n",
    "                                                               minor_thresholds=(2, .5)))\n",
    "axes[1].tick_params(axis='x', labelsize=mpl.rcParams['xtick.labelsize'], which='both')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0a6a69bd",
   "metadata": {},
   "source": [
    "*top*: Simulated data and two model fits, assuming different ARFs and RMFs. \"Special extraction\" uses special qualifiers to match marx simulations, while \"specextract\" uses standard CIAO tools without any special qualifiers. \n",
    "\n",
    "*bottom*: Shape of the ARFs used in the two extractions. Since the ARF is different, the model values are different when fitting to the same data (e.g. where the ARF is lower, the model flux has to be higher to match the data, leading to different slopes and normalizations in the two fits)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6b90e0f9",
   "metadata": {},
   "source": [
    "#### Input parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fad42d86",
   "metadata": {},
   "outputs": [],
   "source": [
    "my_src"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fd958842",
   "metadata": {},
   "source": [
    "#### Fit with special extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4de2ce67",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_special"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fc9ab96f",
   "metadata": {},
   "source": [
    "#### Fit with CIAO default extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2f249c7a",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_specextract"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e3ebbeec",
   "metadata": {},
   "source": [
    "The tables above show the input parameters and the best-fit parameters for the two extraction methods. As expected, the fit using the special extraction method recovers the input parameters better (and typically within the uncertainties), while the standard `specextract` method shows larger deviations."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7f7a342b",
   "metadata": {},
   "source": [
    "## Powerlaw spectrum of an off-axis source\n",
    "Same as above, but for an off-axis source on ACIS-I."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7d7ce551",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run('marx SourceFlux=-1 SpectrumType=FILE SpectrumFile=marx_input.tbl ExposureTime=60000 ' + \n",
    "                     'TStart=2015.5 OutputDir=marx GratingType=NONE DetectorType=ACIS-I DitherModel=INTERNAL ' +\n",
    "                     'RA_Nom=30 Dec_Nom=40 SourceRA=29.9814917 SourceDEC=40.1508083', shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx marx_evt2.fits', shell=True, capture_output=True)\n",
    "out3 = subprocess.run('marxasp MarxDir=marx OutputFile=marx_asol1.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6abb6a83",
   "metadata": {},
   "outputs": [],
   "source": [
    "special_extraction(4200, 5200, 200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1ade033e",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    rt.specextract(f\"marx_evt2.fits[sky=circle(4200,5200,200)]\", \"spec\", asp=\"marx_asp.fits\", weight=False,\n",
    "                clobber=True, mskfile=\"NONE\", badpixfile=\"NONE\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ee7f88be",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.load_pha(\"special extraction\", 'marx_pha.fits')\n",
    "    ui.load_rmf(\"special extraction\", 'marx_rmf.fits')\n",
    "    ui.load_arf(\"special extraction\", 'marx_arf.fits')\n",
    "    ui.load_data(\"specextract\", 'spec_grp.pi')\n",
    "    ui.group_counts(\"special extraction\", 25)\n",
    "    ui.group_counts(\"specextract\", 25)\n",
    "    ui.ignore(None, 0.3)\n",
    "    ui.ignore(7, None)\n",
    "    # set source properties\n",
    "    ui.set_source(\"special extraction\", ui.xsphabs.a1 * ui.xspowerlaw.p1)\n",
    "    ui.set_source(\"specextract\", ui.xsphabs.a2 * ui.xspowerlaw.p2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "56b70ed0",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"special extraction\")\n",
    "    ui.conf(\"special extraction\")\n",
    "    conf_special = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "778801db",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"specextract\")\n",
    "    ui.conf(\"specextract\")\n",
    "    conf_specextract = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "524bc166",
   "metadata": {},
   "outputs": [],
   "source": [
    "a1 = ui.get_arf(\"special extraction\")\n",
    "a2 = ui.get_arf(\"specextract\")\n",
    "# bring on same energy grid\n",
    "engrid = np.arange(0.3, 10., 0.05)\n",
    "a1 = np.interp(engrid, 0.5 * (a1.energ_lo + a1.energ_hi), a1.get_y())\n",
    "a2 = np.interp(engrid, 0.5 * (a2.energ_lo + a2.energ_hi) , a2.get_y())\n",
    "\n",
    "\n",
    "fig, axes = plt.subplots(2, 1, sharex=True, figsize=(8, 6))\n",
    "plt.sca(axes[0])\n",
    "ui.plot_data(\"special extraction\", xlog=True, ylog=True, clearwindow=False)\n",
    "ui.plot_model(\"special extraction\", overplot=True, label=\"special extraction\")\n",
    "ui.plot_model(\"specextract\", overplot=True, label=\"specextract\")\n",
    "axes[0].legend()\n",
    "axes[0].set_title(\"Simulated data with fits using different ARFs and RMFs\")\n",
    "\n",
    "axes[1].loglog(engrid, a1, label=\"special extraction\", c=\"C1\")\n",
    "axes[1].loglog(engrid, a2, label=\"specextract\", c=\"C2\")\n",
    "axes[1].set_xlabel(\"Energy (keV)\")\n",
    "axes[1].set_ylabel(\"Effective Area (cm$^2$)\")\n",
    "axes[1].legend()\n",
    "\n",
    "# Better setting to display labels on a log axis\n",
    "axes[1].get_xaxis().set_minor_formatter(mpl.ticker.LogFormatterMathtext(labelOnlyBase=False,\n",
    "                                                               minor_thresholds=(2, .5)))\n",
    "axes[1].tick_params(axis='x', labelsize=mpl.rcParams['xtick.labelsize'], which='both')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29e6b5f3",
   "metadata": {},
   "source": [
    "#### Input parameters\n",
    "(some as above, but printed here again)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "796c0bd0",
   "metadata": {},
   "outputs": [],
   "source": [
    "my_src"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d941a832",
   "metadata": {},
   "source": [
    "#### Fit with special extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1f2429fb",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_special"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e759efb7",
   "metadata": {},
   "source": [
    "#### Fit with CIAO default extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "12ef1db8",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_specextract"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "14c64408",
   "metadata": {},
   "source": [
    "For the off-axis simulation, the difference between the two extraction methods is smaller, probably because we are using the ACIS-I detector here."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6d4f1145",
   "metadata": {},
   "source": [
    "## Two thermal components on ACIS-I, on-axis\n",
    "Same as above, but for a front-illuminated ACIS-I chip and using\n",
    "an input spectrum with two thermal components similar to a stellar corona."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "22eeed57",
   "metadata": {},
   "outputs": [],
   "source": [
    "ui.set_source(1, ui.xsvapec.apec1 + ui.xsvapec.apec2)\n",
    "apec1.Ne.frozen = False\n",
    "apec2.Ne = apec1.Ne\n",
    "apec1.kT = 0.7\n",
    "apec1.Ne = 2.0\n",
    "apec1.norm = 0.0002\n",
    "apec2.kT = 2.0\n",
    "apec2.norm = 0.0004\n",
    "\n",
    "# get source\n",
    "my_src = ui.get_source(1)\n",
    "\n",
    "# set energy grid\n",
    "bin_width = 0.01\n",
    "energies = np.arange(0.15, 12., bin_width)\n",
    "\n",
    "# evaluate source on energy grid\n",
    "flux = my_src(energies[:-1], energies[1:])\n",
    "\n",
    "ui.save_arrays(\"marx_input.tbl\", [energies[1:], flux / bin_width], \n",
    "               [\"keV\",\"photons/s/cm**2/keV\"], ascii=True, clobber=True)\n",
    " "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7730b400",
   "metadata": {},
   "outputs": [],
   "source": [
    "import subprocess\n",
    "\n",
    "out = subprocess.run('marx SourceFlux=-1 SpectrumType=FILE SpectrumFile=marx_input.tbl ExposureTime=30000 ' + \n",
    "                     'TStart=2015.5 OutputDir=marx GratingType=NONE DetectorType=ACIS-I DitherModel=INTERNAL ' +\n",
    "                     'RA_Nom=30 Dec_Nom=40 SourceRA=30 SourceDEC=40', shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx marx_evt2.fits', shell=True, capture_output=True)\n",
    "out3 = subprocess.run('marxasp MarxDir=marx OutputFile=marx_asol1.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ec99f144",
   "metadata": {},
   "outputs": [],
   "source": [
    "special_extraction(4096.4, 4096.4, 20.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "112643d1",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    rt.specextract(f\"marx_evt2.fits[sky=circle(4096.5,4096.5,20)]\", \"spec\", asp=\"marx_asp.fits\", weight=False,\n",
    "                clobber=True, mskfile=\"NONE\", badpixfile=\"NONE\")\n",
    "       \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "02e32aa2",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.load_pha(\"special extraction\", 'marx_pha.fits')\n",
    "    ui.load_rmf(\"special extraction\", 'marx_rmf.fits')\n",
    "    ui.load_arf(\"special extraction\", 'marx_arf.fits')\n",
    "    ui.load_data(\"specextract\", 'spec_grp.pi')\n",
    "    ui.group_counts(\"special extraction\", 25)\n",
    "    ui.group_counts(\"specextract\", 25)\n",
    "    ui.ignore(None, 0.3)\n",
    "    ui.ignore(7, None)\n",
    "    # set source properties\n",
    "    ui.set_source(\"special extraction\", ui.xsvapec.apec1_1 + ui.xsvapec.apec2_1)\n",
    "    ui.set_source(\"specextract\", ui.xsvapec.apec1_2 + ui.xsvapec.apec2_2)\n",
    "\n",
    "    apec1_1.Ne.frozen = False\n",
    "    apec2_1.Ne = apec1_1.Ne\n",
    "    apec1_2.Ne.frozen = False\n",
    "    apec2_2.Ne = apec1_2.Ne\n",
    "\n",
    "    # Set some starting values close to the true value\n",
    "    apec1_1.kT = 0.9\n",
    "    apec1_1.Ne = 1.5\n",
    "    apec1_1.norm = 0.00015\n",
    "    apec2_1.kT = 1.8\n",
    "    apec2_1.norm = 0.00035\n",
    "    apec1_2.kT = 0.9\n",
    "    apec1_2.Ne = 1.5\n",
    "    apec1_2.norm = 0.00015\n",
    "    apec2_2.kT = 1.8\n",
    "    apec2_2.norm = 0.00035  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9e480e17",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"special extraction\")\n",
    "    ui.conf(\"special extraction\")\n",
    "    conf_special = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "65687174",
   "metadata": {},
   "outputs": [],
   "source": [
    "with SherpaVerbosity('ERROR'):\n",
    "    ui.fit(\"specextract\")\n",
    "    ui.conf(\"specextract\")\n",
    "    conf_specextract = ui.get_confidence_results()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0e8eb39d",
   "metadata": {},
   "outputs": [],
   "source": [
    "a1 = ui.get_arf(\"special extraction\")\n",
    "a2 = ui.get_arf(\"specextract\")\n",
    "# bring on same energy grid\n",
    "engrid = np.arange(0.3, 10., 0.05)\n",
    "a1 = np.interp(engrid, 0.5 * (a1.energ_lo + a1.energ_hi), a1.get_y())\n",
    "a2 = np.interp(engrid, 0.5 * (a2.energ_lo + a2.energ_hi) , a2.get_y())\n",
    "\n",
    "\n",
    "fig, axes = plt.subplots(2, 1, sharex=True, figsize=(8, 6))\n",
    "plt.sca(axes[0])\n",
    "ui.plot_data(\"special extraction\", xlog=True, ylog=True, clearwindow=False)\n",
    "ui.plot_model(\"special extraction\", overplot=True, label=\"special extraction\")\n",
    "ui.plot_model(\"specextract\", overplot=True, label=\"specextract\")\n",
    "axes[0].legend()\n",
    "axes[0].set_title(\"Simulated data with fits using different ARFs and RMFs\")\n",
    "\n",
    "axes[1].loglog(engrid, a1, label=\"special extraction\", c=\"C1\")\n",
    "axes[1].loglog(engrid, a2, label=\"specextract\", c=\"C2\")\n",
    "axes[1].set_xlabel(\"Energy (keV)\")\n",
    "axes[1].set_ylabel(\"Effective Area (cm$^2$)\")\n",
    "axes[1].legend()\n",
    "\n",
    "# Better setting to display labels on a log axis\n",
    "axes[1].get_xaxis().set_minor_formatter(mpl.ticker.LogFormatterMathtext(labelOnlyBase=False,\n",
    "                                                               minor_thresholds=(2, .5)))\n",
    "axes[1].tick_params(axis='x', labelsize=mpl.rcParams['xtick.labelsize'], which='both')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "84ff66e7",
   "metadata": {},
   "source": [
    "*top*: Simulated data and two model fits, assuming different ARFs and RMFs. \"Special extraction\" uses special qualifiers to match marx simulations, while \"specextract\" uses standard CIAO tools without any special qualifiers. \n",
    "\n",
    "*bottom*: Shape of the ARFs used in the two extractions. Since the ARF is different, the model values are different when fitting to the same data (e.g. where the ARF is lower, the model flux has to be higher to match the data, leading to different slopes and normalizations in the two fits)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eee12ccc",
   "metadata": {},
   "source": [
    "#### Input parameters"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e6f9d377",
   "metadata": {},
   "outputs": [],
   "source": [
    "my_src"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "aa8df6ae",
   "metadata": {},
   "source": [
    "#### Fit with special extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a2c53d75",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_special"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "25775017",
   "metadata": {},
   "source": [
    "#### Fit with CIAO default extraction"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cd7a634f",
   "metadata": {},
   "outputs": [],
   "source": [
    "conf_specextract"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5aa3d5f4",
   "metadata": {},
   "source": [
    "Again we are looking at an ACIS-I simulation and the differences between the two extraction methods are smaller than for ACIS-S. While the Ne abundance is not well-constrained in this case, the fitted values are in general in agreement with the input values."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ciao-4.18.b2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
