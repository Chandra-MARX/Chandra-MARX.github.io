{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dc04ddc7",
   "metadata": {
    "tags": [
     "remove-cell"
    ]
   },
   "outputs": [],
   "source": [
    "from utils import setup_marx, setup_saotrace\n",
    "setup_marx()\n",
    "trace_nest = setup_saotrace()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "41bf6772",
   "metadata": {},
   "source": [
    "# Wings of the Chandra PSF\n",
    "The Chandra PSF falls in two regimes: The shape of the core is set by quasi-specular\n",
    "reflection from low-frequency surface errors. This component is strongly peaked and dominates\n",
    "in the innermost few arcseconds (for an on-axis source). The outer part of the PSF has the shape of a powerlaw with a spectral index close to two and is caused by micro-roughness on the mirror surfaces. The [Proposer's Observatory Guide](http://cxc.harvard.edu/proposer/POG/html/chap4.html#tth_sEc4.2.3) and [a memo by T.J. Gaetz](http://cxc.harvard.edu/cal/Hrma/rsrc/Publish/Optics/PSFWings/wing_analysis_rev1b.pdf) discuss this in a lot more detail. The memo is based on a very detailed analysis of a deep Her-X1 observation. In this test we replicate that observation in marx and SAOTrace simulations.\n",
    "\n",
    "In the memo, T.J. Gaetz goes to great lengths to separate the effect of the intrinsic Chandra PSF on the data from other influences such as the ACIS contamination. When we compare data and marx simulation below, we chose a somewhat simpler approach. We perform steps to mitigate the impact of other astrophysical sources (which are not part of the marx simulation) and background (which is not part of the marx simulation). On the other hand, we just compare the observed count rates with no correction for the ACIS contamination, dithering near chip edges etc. because those effects are included in both the observed and the simulated data.\n",
    "\n",
    "Read the code for this test to see all details of the data extraction, but here are the most\n",
    "important points:\n",
    "\n",
    "- The source is heavily piled-up, thus the source spectrum is taken from the read-out streak.\n",
    "- Because of pile-up in the data, all fitting is restricted to radii above 15 arcsec."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a9de312c",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import subprocess\n",
    "\n",
    "from astropy.coordinates import SkyCoord\n",
    "from astropy.io import fits\n",
    "import numpy as np\n",
    "\n",
    "import ciao_contrib.runtool as rt\n",
    "from ciao_contrib.cda.data import download_chandra_obsids\n",
    "from coords.chandra import cel_to_chandra\n",
    "\n",
    "from utils import marxpars_from_asol, write_spectrum_from_fluxcorrection\n",
    "\n",
    "out = download_chandra_obsids([3662])\n",
    "\n",
    "asolfile = '3662/primary/pcadf03662_000N001_asol1.fits.gz'\n",
    "evt2file = '3662/primary/acisf03662N004_evt2.fits.gz'\n",
    "\n",
    "'''Source is heavily piled-up so we extract the source spectrum from the read-out streak.'''\n",
    "source_reg = 'rotbox(3922.6168,3556.9146,12,512,332.71498)'\n",
    "\n",
    "'''The analysis makes narrow band count rate images.\n",
    "Bands are defined here. If they are too wide, then the effective area and spectrum\n",
    "within one band cannot be taken as constant any longer, but if they are too narrow\n",
    "the test will need a very long time to run.\n",
    "'''\n",
    "energy_bins = np.array([.4, .5, .6, .7, .9, 1., 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.,\n",
    "                    3.5, 4., 4.5, 5., 5.5, 6., 6.5, 7., 7.5, 8.])\n",
    "mid_bins = 0.5 * (energy_bins[:-1] + energy_bins[1:])\n",
    "    \n",
    "sky_coos = SkyCoord.from_name('Her X-1')\n",
    "coos = cel_to_chandra(fits.getheader(evt2file, 1), sky_coos.ra.degree, sky_coos.dec.degree)\n",
    "x = coos['x'][0]\n",
    "y = coos['y'][0]\n",
    "write_spectrum_from_fluxcorrection(asolfile, evt2file, x, y, source_reg, \n",
    "                                                # Rough estimate of normalization\n",
    "                                                # Read-out streak region is 512 pix long\n",
    "                                                0.00004*512/3.2)\n",
    "\n",
    "\n",
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['SpectrumType'] = 'FILE'\n",
    "pars['SpectrumFile'] = 'input_spec_marx.tbl'\n",
    "pars['OutputDir'] = 'marx_only'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "asolh = fits.getheader(asolfile, 1)\n",
    "evth = fits.getheader(evt2file, 1)\n",
    "\n",
    "lua_text = f'''\n",
    "ra_pnt = {asolh['RA_NOM']}\n",
    "dec_pnt = {asolh['DEC_NOM']}\n",
    "roll_pnt = {asolh['ROLL_NOM']}\n",
    "\n",
    "dither_asol_chandra{{ file = \"{asolfile}\",\n",
    "                    ra = ra_pnt, dec = dec_pnt, roll = roll_pnt }}\n",
    "\n",
    "point{{ position = {{ ra = {evth['RA_TARG']},\n",
    "        dec = {evth['DEC_TARG']},\n",
    "        ra_aimpt = ra_pnt,\n",
    "        dec_aimpt = dec_pnt,\n",
    "    }},\n",
    "    spectrum = {{ {{ file = \"input_spec_saotrace.rdb\",\n",
    "                    units = \"photons/s/cm2\",\n",
    "                    scale = 1,\n",
    "                    format = \"rdb\",\n",
    "                    emin = \"ENERG_LO\",\n",
    "                    emax = \"ENERG_HI\",\n",
    "                    flux = \"flux\"}} }}\n",
    "    }}\n",
    "'''\n",
    "with open('saotrace_source.lua', 'w') as f:\n",
    "    f.write(lua_text)\n",
    "\n",
    "'''\n",
    "CXO time numbers are large and round-off error can appear\n",
    "which make SAOTrace fail.\n",
    "Therefore, shorten all times by about 0.01 sec to make sure.\n",
    "'''\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02\n",
    "\n",
    "subprocess.run(trace_nest +\n",
    "               f' tag=saotrace srcpars=saotrace_source.lua tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec',\n",
    "               shell=True)\n",
    "pars['OutputDir'] = 'marx_saotrace'\n",
    "pars['SourceType'] = 'SAOSAC'\n",
    "pars['SAOSACFile'] = 'saotrace.fits'\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "out = subprocess.run('marx2fits --pixadj=EDSER marx_only marx_only.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx_saotrace marx_saotrace.fits', shell=True, \n",
    "                     capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "74e26fad",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "'''Make image and run cell detect to find exclusion regions for extraction.'''\n",
    "rt.dmcopy(evt2file+\"[bin x=3700:4300:1,y=3700:4300:1][opt type=i4]\",\n",
    "            \"im.fits\", option=\"image\", clobber=True)\n",
    "rt.mkpsfmap(\"im.fits\", \"psf.map\", 1.4, ecf=0.5, clobber=True)\n",
    "rt.celldetect(\"im.fits\", \"im_src.fits\", psffile=\"psf.map\", clobber=True)\n",
    "rt.asphist(asolfile, \"asphist_7.fits\", evtfile=f\"{evt2file}[ccd_id=7]\", clobber=True)\n",
    "'''Create exposure maps\n",
    "\n",
    "Also, make exposure map for S-3 chip to correct for dither etc. Mirror effective\n",
    "area is not included in that calculation, because all the photons we care for come\n",
    "from the same source, not from different positions on the sky, thus the mirror\n",
    "effective area is the constant for the source we look at.\n",
    "\n",
    "The instrument map depends strongly on the energy. We will thus pass in the\n",
    "source spectrum. This gives us one map appropriately scaled for the whole spectrum.\n",
    "However, in later analysis, we want to split the data in narrower bands.\n",
    "When looking at that accurately, we need to have one map for each band.\n",
    "\n",
    "Also, the observed data contains bad pixels, while the marx simulated data does not.\n",
    "This means that we need to make a second set of maps with no bad pixels in them.\n",
    "'''\n",
    "for e, e_mid in zip(energy_bins[:-1], mid_bins):\n",
    "    for name, bpix in zip(['', '_marx'], ['', ';BPMASK=0x00000']):\n",
    "        rt.mkinstmap(f'instmap_{e:3.1f}{name}.fits', monoenergy=e_mid, pixelgrid=\"1:1024:#1024,1:1024:#1024\", \n",
    "            obsfile=f\"{evt2file}[EVENTS]\", dafile=\"NONE\", detsubsys=f\"ACIS-S3{bpix}\", \n",
    "            mirror=\"HRMA;AREA=1\", grating=\"NONE\", maskfile=\"NONE\", spectrumfil=\"NONE\",\n",
    "            clobber=True)\n",
    "        rt.mkexpmap(\"asphist_7.fits\", f\"expmap_{e:3.1f}{name}.fits\", \n",
    "                    f\"instmap_{e:3.1f}{name}.fits\", \n",
    "                    xygrid=\"2975:4400:#512,3250:4650:#512\", clobber=True, \n",
    "                    useavgaspect=False)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2175791a",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "from astropy.table import Table\n",
    "'''Clean bogus sources from src file and write regions\n",
    "\n",
    "celldetect always detects plenty of sources on the read-out streak and\n",
    "around the piled-up regions.\n",
    "For processing speed and clarity we want to remove those bogus detections\n",
    "from the source list.\n",
    "'''\n",
    "src = Table.read('im_src.fits', hdu=1)\n",
    "# Get sources within 50 pix of Her X-1. We don't look there anyway because of pile-up\n",
    "src['d_herx1'] = np.sqrt((src['X'] - x)**2 + (src['Y'] - y)**2)\n",
    "d_src = src['d_herx1'] < 50.\n",
    "# Get sources on the read-out streak\n",
    "# 2 points on streak\n",
    "p1 = np.array([3772., 3264.])\n",
    "p2 = np.array([4251., 4193.])\n",
    "# n is normal to read-out streak\n",
    "n = np.array([1., - (p2[0] - p1[0]) / (p2[1] - p1[1])])\n",
    "n = n / np.linalg.norm(n)\n",
    "vec_x = np.vstack([src['X'], src['Y']])\n",
    "d_line = np.abs(np.dot(n, (p1 - vec_x.T).T)) < 2.\n",
    "src = src[~d_src & ~d_line]\n",
    "\n",
    "# box for readout streak\n",
    "streak = 'rotbox(4010.0285,3725.3416,18.240189,1085.0354,332.74569)'\n",
    "# Assemble regions for extraction:\n",
    "n_rings = 50\n",
    "r_rings = np.logspace(np.log10(7.), np.log10(500.), n_rings + 1) / 0.492\n",
    "with open('annuli.stk', 'w') as f:\n",
    "    for i in range(n_rings):\n",
    "        reg = f'annulus({x}, {y}, {r_rings[i]}, {r_rings[i + 1]})'\n",
    "        reg += '-' + streak\n",
    "        # find sources that overlap this ring\n",
    "        ind1 = src['d_herx1'] + src['R'][:, 0] > r_rings[i]\n",
    "        ind2 = src['d_herx1'] - src['R'][:, 0] < r_rings[i + 1]\n",
    "        src_intersect = src[ind1 & ind2]\n",
    "        for s in src_intersect:\n",
    "            reg += f'-ellipse({s[\"X\"]}, {s[\"Y\"]}, {s[\"R\"][0]}, {s[\"R\"][1]}, {s[\"ROTANG\"]})'\n",
    "        f.write(reg + '\\n')\n",
    "for efile, name, outname in zip([evt2file, 'marx_only.fits', 'marx_saotrace.fits'],\n",
    "                                ['', '_marx', '_marx'],\n",
    "                                ['_obs', '_marx', '_saotrace']):\n",
    "    # Energy in fits file in in eV not, keV, thus a factor of 1000 here\n",
    "    for e_lo, e_up in zip(energy_bins[:-1] * 1000, energy_bins[1:] * 1000):\n",
    "        estr = f\"_{e_lo/1000:3.1f}\"\n",
    "        rt.dmextract(f\"{efile}[energy={e_lo}:{e_up}][bin sky=@annuli.stk]\",\n",
    "         f\"profile{estr}{outname}.fits\", \n",
    "         exp=f\"expmap{estr}{name}.fits\", opt=\"generic2\", clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "af63424a",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "'''Analyze and plot results - Plot 1'''\n",
    "import pycrates\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "from sherpa.data import Data1D\n",
    "from sherpa.models.basic import Const1D, PowLaw1D\n",
    "from sherpa.stats import Chi2\n",
    "from sherpa.optmethods import LevMar\n",
    "from sherpa.fit import Fit\n",
    "\n",
    "# set up Sherpa fitting\n",
    "const1d = Const1D()\n",
    "const1d.c0.min = 0\n",
    "pow1d = PowLaw1D()\n",
    "stat = Chi2()\n",
    "opt = LevMar()\n",
    "\n",
    "fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8), sharex=True)\n",
    "energy_index = [1, 8, 18, 24]\n",
    "fullname = {'obs': 'Observation', 'marx': 'MARX',\n",
    "                        'saotrace': 'SAOTrace + MARX'}\n",
    "for i, ax in enumerate(axes.flatten()):\n",
    "    e = energy_bins[energy_index[i]]\n",
    "    e_upper = energy_bins[energy_index[i] + 1]\n",
    "    for j, name in enumerate(['obs', 'marx', 'saotrace']):\n",
    "        tab = pycrates.read_file(f'profile_{e:3.1f}_{name}.fits')\n",
    "        r = np.mean(tab.get_column('r').values, axis=1)\n",
    "        r_arcsec = r * 0.492\n",
    "        indfit = r_arcsec > 15.\n",
    "        plots = ax.errorbar(r_arcsec, tab.get_column('SUR_FLUX').values,\n",
    "                            yerr=tab.get_column('SUR_FLUX_ERR').values,\n",
    "                            label='__no_legend__')\n",
    "\n",
    "        if name == 'obs':\n",
    "            mymod = const1d + pow1d\n",
    "            const1d.c0.val = tab.get_column('SUR_FLUX').values[-1]\n",
    "        else:\n",
    "            mymod = pow1d\n",
    "        data = Data1D('', r[indfit], tab.get_column('SUR_FLUX').values[indfit],\n",
    "                        staterror=tab.get_column('SUR_FLUX_ERR').values[indfit])\n",
    "        gfit = Fit(data, mymod, stat=stat, method=opt)\n",
    "        gfit.fit()\n",
    "\n",
    "        ax.plot(r_arcsec, mymod(r), label=fullname[name],\n",
    "                color=plots[0].get_color())\n",
    "        ax.set_title(f'{e:3.1f} - {e_upper:3.1f} keV')\n",
    "        ax.loglog()\n",
    "\n",
    "ax.set_xlim(6, 550)\n",
    "for ax in axes[:, 0]:\n",
    "    ax.set_ylabel('flux per area')\n",
    "for ax in axes[1, :]:\n",
    "    ax.set_xlabel('radius [arcsec]')\n",
    "\n",
    "_ = ax.legend(fontsize='small', loc='lower left')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6029e19e",
   "metadata": {},
   "source": [
    "The flux in the scattering halo drops as a powerlaw with increasing distance from the source. \n",
    "**In these plots, we should look only at the slope, not the absolute normalization** because the total count rate is uncertain in the observation due to the severe pile-up, so the input flux to the simulations might be lower than the true flux.\n",
    "\n",
    "The plots show the data (with purely statistical uncertainties) and powerlaw fits. Due to the background that is part of the observations but not the simulated data, the powerlaw flattens out for the observed data at high and low energies, where the total count number is low and thus the background more important.  We add a constant to the powerlaw model to account for this. SAOTrace simulations produce a fairly smooth powerlaw similar to the observations. The pure marx simulations have much larger deviations due to marx's simplified mirror model."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0645a598",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "'''Analyze and plot results - Plot 2'''\n",
    "slopes = np.zeros((len(energy_bins) - 1, 3))\n",
    "for i, e in enumerate(energy_bins[:-1]):\n",
    "    for j, name in enumerate(['obs', 'marx', 'saotrace']):\n",
    "        tab = pycrates.read_file(f'profile_{e:3.1f}_{name}.fits')\n",
    "        r = np.mean(tab.get_column('r').values, axis=1)\n",
    "        r_arcsec = r * 0.492\n",
    "        indfit = r_arcsec > 15.\n",
    "        if name == 'obs':\n",
    "            mymod = const1d + pow1d\n",
    "            const1d.c0.val = tab.get_column('SUR_FLUX').values[-1]\n",
    "        else:\n",
    "            mymod = pow1d\n",
    "        data = Data1D('', r[indfit], tab.get_column('SUR_FLUX').values[indfit],\n",
    "                        staterror=tab.get_column('SUR_FLUX_ERR').values[indfit])\n",
    "        gfit = Fit(data, mymod, stat=stat, method=opt)\n",
    "        gfit.fit()\n",
    "\n",
    "        slopes[i, j] = pow1d.gamma.val\n",
    "\n",
    "fig, ax = plt.subplots()\n",
    "for i, name in enumerate(['Observation', 'MARX', 'SAOTrace + MARX']):\n",
    "    ax.plot(mid_bins, slopes[:, i], label=name)\n",
    "    ax.legend()\n",
    "    ax.set_xlabel('energy [keV]')\n",
    "    ax.set_ylabel('slope of powerlaw')\n",
    "_ = ax.set_xlim(0, None)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7cd4bebd",
   "metadata": {},
   "source": [
    "The surface brightness falls off with increasing distance from the source position as a powerlaw. The exponent of this powerlaw depends on the photon energy as shown in the figure. If spectra are extracted in the scattering halo the observed spectrum will thus change with distance from the source. For the observed data, the low energy end (below about 1 keV) has to be taken with a grain of salt. We applied a correction for the ACIS contamination in the data reduction, but the distribution of the contaminant over the detector area is not well known, leading to systematic uncertainties. For energies above 5 keV, the outer mirror shell does not contribute much effective area any longer. This shell has the roughest surface, which explains why we observe steeper powerlaw slopes for higher energies. Both the marx and the SAOTrace mirror model also have energy dependent exponents."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "401e606c",
   "metadata": {},
   "source": [
    "## Summary\n",
    "Both marx and SAOTrace simulations reproduce the wings of the Chandra PSF reasonably well. There are differences in the details, but there is also some uncertainty in the observed data, which, unlike the simulations, contains background events and some detector effects not modeled in marx. It is important to remember though that we study the wings out to several arcminutes here. In all but the brightest sources on the sky, the wings will be undetectable this far out, simply because the total count rate out in the wings is orders of magnitude lower than the in the center of the PSF and will be lost in the background."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ciao-4.18.b2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
