{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "836ae595",
   "metadata": {},
   "source": [
    "# Source shapes in MARX\n",
    "marx offers different source shapes. Tests in this module exercise those sources (except ``SAOSAC``, which is heavily used in the PSF tests already)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a0742783",
   "metadata": {
    "tags": [
     "remove-cell"
    ]
   },
   "outputs": [],
   "source": [
    "from utils import setup_marx\n",
    "setup_marx()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c87956a8",
   "metadata": {},
   "source": [
    "## Build-in geometric sources\n",
    "This test exercises build-in marx sources with different geometric shapes.\n",
    "Most source types have parameters, and not all parameters are tested here.\n",
    "See source documentation for a detailed description of source parameters."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "762dd73d",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import subprocess\n",
    "from matplotlib import pyplot as plt\n",
    "import pycrates\n",
    "\n",
    "sources = [ {'OutputDir': 'point'}, # Default shape is POINT\n",
    "            {'SourceType': 'GAUSS', 'S-GaussSigma': 20, 'OutputDir': 'gauss'},\n",
    "            {'SourceType': 'BETA', 'S-BetaCoreRadius': 10,'S-BetaBeta': 0.6, 'OutputDir': 'beta'},\n",
    "            {'SourceType': 'DISK', 'S-DiskTheta0': 0, 'S-DiskTheta1': 20, 'OutputDir': 'disk'},\n",
    "            {'SourceType': 'DISK', 'S-DiskTheta0': 10, 'S-DiskTheta1': 20, 'OutputDir': 'diskhole'},\n",
    "            {'SourceType': 'LINE', 'S-LinePhi': 45, 'S-LineTheta': 30, 'OutputDir': 'line'},\n",
    "        ]\n",
    "for src in sources:\n",
    "    marxcall = ['marx GratingType=NONE'] + ['{0}={1}'.format(k, v) for k, v in src.items()]\n",
    "    marxcall = ' '.join(marxcall)\n",
    "    out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=EDSER {src[\"OutputDir\"]} {src[\"OutputDir\"]}.fits', \n",
    "                             shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aa3c0b9f",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(2, 3, figsize=(10,6), subplot_kw={'aspect':'equal'})\n",
    "for ax, src in zip(axes.flatten(), sources):\n",
    "    evt = pycrates.read_file(f'{src[\"OutputDir\"]}.fits')\n",
    "    out = ax.hist2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                    bins=100, range=[[3900,4150], [4000,4250]])\n",
    "    out = ax.set_title(src['OutputDir'])\n",
    "    ax.set_axis_off()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "53348e99",
   "metadata": {},
   "source": [
    "## Image as source\n",
    "An image can be used as marx input. In this case, the intensity of the\n",
    "X-ray radiation on the sky is taken to be proportional to the value of the\n",
    "image at that point.\n",
    "\n",
    "In this example we use Python to make a simple image as input, but one could use any fits image, e.g. a source observed in a different wavelength or the output of a simulation.\n",
    "In the Python code, we set up a 3-d box and fill it with an emitting shell. We then integrate along one dimension to obtain a collapsed image. Physically, this represents the thin shell of a supernova explosion."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3981463f",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from astropy.wcs import WCS\n",
    "from astropy.io import fits\n",
    "\n",
    "# Actually to make this run faster, we'll do only one quadrant here\n",
    "cube = np.zeros((201, 201, 201))\n",
    "mg = np.mgrid[0: 201., 0:201, 0:201 ]\n",
    "d = np.sqrt(mg[0, :, :, :]**2 + mg[1, :, :, :]**2 + mg[2, :, :, :]**2)\n",
    "cube[(d > 160.) & (d < 170)] = 1\n",
    "im = cube.sum(axis=0)\n",
    "# Now rotate and put the four quarters together\n",
    "image = np.zeros((401, 401))\n",
    "image[:201, :201] = np.fliplr(np.flipud(im))\n",
    "image[:201, 200:] = np.flipud(im)\n",
    "image[200:, :201] = np.fliplr(im)\n",
    "image[200:, 200:] = im\n",
    "\n",
    "# Create a new WCS object.\n",
    "w = WCS(naxis=2)\n",
    "w.wcs.crpix = [100., 100.]\n",
    "# Pixel size of our image shall be 1 arcsec\n",
    "w.wcs.cdelt = [1. / 3600., 1. / 3600.]\n",
    "w.wcs.ctype = [\"RA---TAN\", \"DEC--TAN\"]\n",
    "\n",
    "# Now, write out the WCS object as a FITS header\n",
    "header = w.to_header()\n",
    "\n",
    "# header is an astropy.io.fits.Header object.  We can use it to create a new\n",
    "# PrimaryHDU and write it to a file.\n",
    "hdu = fits.PrimaryHDU(header=header, data=image)\n",
    "\n",
    "# Save to FITS file\n",
    "hdu.writeto('input_image.fits', overwrite=True)\n",
    "\n",
    "out = subprocess.run('marx SourceType=IMAGE S-ImageFile=input_image.fits MinEnergy=1.9 MaxEnergy=1.9 GratingType=NONE OutputDir=image',\n",
    "                      shell=True, capture_output=True)\n",
    "out2 = subprocess.run(f'marx2fits --pixadj=EDSER image image.fits', \n",
    "                             shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "eb8ea0ca",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(1, 2, figsize=(10,6), subplot_kw={'aspect':'equal'})\n",
    "input_image = pycrates.read_file('input_image.fits')\n",
    "axes[0].imshow(image, origin='lower')\n",
    "axes[0].set_title('input image')\n",
    "\n",
    "evt = pycrates.read_file(f'image.fits')\n",
    "out = axes[1].hist2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                    bins=100, range=[[3600,4600], [3600,4600]])\n",
    "axes[1].set_title('Binned events from marx')\n",
    "for ax in axes:\n",
    "    ax.set_axis_off()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "35392e50",
   "metadata": {},
   "source": [
    "The left image shows the input image, the right image the binned events from marx using that image as source. Note that the apparent size of the images is different, since the scale is in pixels, not in Ra/Dec and the pixel size of the input image differs from the ACIS pixel size."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e8b707a1",
   "metadata": {},
   "source": [
    "## Using a RAYFILE source\n",
    "marx is a Monte-Carlo code, thus the exact distribution of photons\n",
    "on the sky will be different every time the code is run. Sometimes it\n",
    "can be useful to generate a list of photons with position, time and\n",
    "energy from the source on the sky and then \"observe\" the exact same list\n",
    "with different instrument configurations so that any differences in the\n",
    "result are only due to the different configuration and not to random\n",
    "fluctuations in the source.\n",
    "\n",
    "In this example, we look at a relatively large, diffuse emission region\n",
    "with a very soft spectrum (for simplicity we are using a flat spectrum).\n",
    "We compare simulations using ACIS-S and ACIS-I. ACIS-S has a better\n",
    "response to soft photons, but some parts of the source may not be in the\n",
    "field-of-view; ACIS-I is less efficient for soft photons, but has a\n",
    "larger field-of-view.\n",
    "For the simulation, we pick a date early in the Chandra mission, since the contamination layer on ACIS was still thin at the time. Today, neither ACIS-S nor ACIS-I would detect many photons from such a soft source."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "97be0b1e",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "out = subprocess.run('marx SourceType=GAUSS S-GaussSigma=300 MinEnergy=0.3 MaxEnergy=0.8 GratingType=NONE DumpToRayFile=yes ExposureTime=30000',\n",
    "                      shell=True, capture_output=True)\n",
    "for n in 'si':\n",
    "    out = subprocess.run(f'marx SourceType=RAYFILE RayFile=marx.output OutputDir=acis{n} DetectorType=ACIS-{n.upper()} TStart=2005',\n",
    "                         shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=EXACT acis{n} acis{n}.fits', \n",
    "                             shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e332e04",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "from mpl_toolkits.axes_grid1 import ImageGrid\n",
    "fig = plt.figure(figsize=(10,6))\n",
    "grid = ImageGrid(\n",
    "    fig, 111,  # similar to fig.add_subplot(142).\n",
    "    nrows_ncols=(1, 2), axes_pad=0.4, label_mode=\"L\", share_all=True,\n",
    "    cbar_location=\"top\", cbar_mode=\"each\")\n",
    "for ax, cax, src in zip(grid, grid.cbar_axes, ['aciss', 'acisi']):\n",
    "    evt = pycrates.read_file(f'{src}.fits')\n",
    "    im = ax.hist2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                    bins=50, range=[[3000,5000], [3000,5000]])\n",
    "    out = ax.set_title('ACIS-' + src[-1].upper())\n",
    "    cax.colorbar(im[-1])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b4fd205c",
   "metadata": {},
   "source": [
    "Both sources are generated from the same photon list. Sometimes the same pattern of photons can be seen in both images, but with a some events missing on ACIS-I due to the lower soft response, while others lie outside of the ACIS-S field-of-view."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8a1a7317",
   "metadata": {},
   "source": [
    "## Compiling a USER source\n",
    "marx comes with several examples for user written sources in C.\n",
    "These can be compiled as shared objects and dynamically linked into marx\n",
    "at run time.\n",
    "To test this, we copy one of the source files from the installed marx\n",
    "version and compile it with gcc. This particular case is not very useful,\n",
    "because marx already has a point source with the same properties\n",
    "build-in. The purpose of this test is only to have a check that\n",
    "the dynamic linking works."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "57caca79",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "import os\n",
    "import shutil\n",
    "\n",
    "marxpath = os.path.dirname(shutil.which('marx'))\n",
    "src = os.path.join(marxpath, '..',\n",
    "                    'share', 'doc', 'marx', 'examples', 'user-source')\n",
    "for f in ['point.c', 'user.h']:\n",
    "    shutil.copy(os.path.join(src, f), f)\n",
    "jdmath_h = os.path.join(marxpath, '..', 'include')\n",
    "jdmath_a = os.path.join(marxpath, '..', 'lib', 'libjdmath.a')\n",
    "\n",
    "out = subprocess.run(['gcc', '-I' + jdmath_h, jdmath_a,\n",
    "                      '-shared', 'point.c', '-o', 'point.so'])\n",
    "\n",
    "out = subprocess.run(f'marx SourceType=USER UserSourceFile=point.so GratingType=NONE OutputDir=userpoint',\n",
    "                         shell=True, capture_output=True)\n",
    "out2 = subprocess.run(f'marx2fits --pixadj=EDSER userpoint userpoint.fits', \n",
    "                             shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e8356a61",
   "metadata": {
    "tags": [
     "hide-input"
    ]
   },
   "outputs": [],
   "source": [
    "fig, axes = plt.subplots(1, 1, figsize=(5, 5), subplot_kw={'aspect':'equal'})\n",
    "evt = pycrates.read_file('userpoint.fits')\n",
    "out = axes.hist2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                bins=100, range=[[4010,4030], [4130,4150]])\n",
    "out = axes.set_title('User compiled point source')\n",
    "#axes.set_axis_off()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4fa6b1a",
   "metadata": {},
   "source": [
    "The distribution of photons looks indeed like a point source; it seems that we compiled and linked the user source file correctly."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ciao-4.18.b2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
