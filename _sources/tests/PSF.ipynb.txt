{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d9de7db0",
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import setup_marx, setup_saotrace\n",
    "setup_marx()\n",
    "trace_nest = setup_saotrace()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1321bf62",
   "metadata": {},
   "source": [
    "# Point Spread Function (PSF)\n",
    "The [point-spread function (PSF) for Chandra](http://cxc.harvard.edu/ciao/PSFs/psf_central.html) describes how the light from a point source is spread over a larger area on the detector. Several effects contribute to this, e.g. scatter from not absolutely perfectly shaped mirrors, the uncertainty in the pointing, the fact that the detectors are flat, while the focal plane of the mirror is curved (specifically for large off-axis angles) and the pixalization of data on detector read-out.\n",
    "\n",
    "The following tests compare marx simulations, [SAOTrace](https://cxc.cfa.harvard.edu/cal/Hrma/Raytrace/SAOTrace.html) simulations, and data to look at different aspects of the Chandra PSF."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "52d3321d",
   "metadata": {},
   "source": [
    "## On-axis PSF on an ACIS-BI chip\n",
    "The PSF depends on many things, some of which are common to all observations\n",
    "like the shape of the mirror, and some are due to detector effects.\n",
    "For ACIS detectors, the\n",
    "[sub-pixel event repositioning (EDSER)](http://cxc.harvard.edu/ciao/why/acissubpix.html)\n",
    "can improve the quality of an image by repositioning events based on the event grade.\n",
    "This correction depends on the type pf chip (FI or BI). This test compares\n",
    "the simulation of a point source on a BI ACIS-S chip to an observation.\n",
    "The observed object is TYC 8241 2652 1, a young star, and was observed in\n",
    "1/8 sub-array mode to reduce pile-up. The pile-up fraction in the data is\n",
    "about 5% in the brightest pixel."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "95657a07",
   "metadata": {},
   "outputs": [],
   "source": [
    "from ciao_contrib.cda.data import download_chandra_obsids\n",
    "from coords.chandra import cel_to_chandra\n",
    "from astropy.io import fits"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b78a9e33",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Download data\n",
    "out = download_chandra_obsids([15713])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5c79cb4",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolfile = '15713/primary/pcadf15713_000N001_asol1.fits.gz'\n",
    "evt2file = '15713/primary/acisf15713N003_evt2.fits.gz'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6c3e234",
   "metadata": {},
   "outputs": [],
   "source": [
    "from astropy.coordinates import SkyCoord\n",
    "tyc = SkyCoord.from_name('TYC 8241 2652 1')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "67323581",
   "metadata": {},
   "outputs": [],
   "source": [
    "coos = cel_to_chandra(fits.getheader(evt2file, 1), tyc.ra.degree, tyc.dec.degree)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "60f75655",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = coos['x'][0]\n",
    "y = coos['y'][0]\n",
    "r = 4\n",
    "region = f'circle({x},{y},{r})'\n",
    "psffrac = 1.0\n",
    "\n",
    "bg_x = 4044\n",
    "bg_y = 4123"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5801c78f",
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import write_spectrum_from_fluxcorrection\n",
    "\n",
    "write_spectrum_from_fluxcorrection(asolfile, evt2file, x, y, region, psffrac=psffrac)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5992d70",
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import marxpars_from_asol\n",
    "\n",
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['SpectrumType'] = 'FILE'\n",
    "pars['SpectrumFile'] = 'input_spec_marx.tbl'\n",
    "pars['OutputDir'] = 'marx_only'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "marxcall\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f89711f0",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Currently, MARX can only be run from the command line. So we build\n",
    "a command line call from the parameters dictionary and run it via\n",
    "subprocess.call().'''\n",
    "import subprocess\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c5a084b2",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolh = fits.getheader(asolfile, 1)\n",
    "evth = fits.getheader(evt2file, 1)\n",
    "\n",
    "def write_saotrace_lua(asolfile, asolh, evth, spectrumfile='input_spec_saotrace.rdb'):\n",
    "    \"\"\"Write an SAOTrace Lua source parameter file.\"\"\"\n",
    "    lua_text = f'''\n",
    "    ra_pnt = {asolh['RA_NOM']}\n",
    "    dec_pnt = {asolh['DEC_NOM']}\n",
    "    roll_pnt = {asolh['ROLL_NOM']}\n",
    "\n",
    "    dither_asol_chandra{{ file = \"{asolfile}\",\n",
    "                        ra = ra_pnt, dec = dec_pnt, roll = roll_pnt }}\n",
    "\n",
    "    point{{ position = {{ ra = {evth['RA_TARG']},\n",
    "            dec = {evth['DEC_TARG']},\n",
    "            ra_aimpt = ra_pnt,\n",
    "            dec_aimpt = dec_pnt,\n",
    "        }},\n",
    "        spectrum = {{ {{ file = \"{spectrumfile}\",\n",
    "                        units = \"photons/s/cm2\",\n",
    "                        scale = 1,\n",
    "                        format = \"rdb\",\n",
    "                        emin = \"ENERG_LO\",\n",
    "                        emax = \"ENERG_HI\",\n",
    "                        flux = \"flux\"}} }}\n",
    "        }}\n",
    "    '''\n",
    "    with open('saotrace_source.lua', 'w') as f:\n",
    "        f.write(lua_text)\n",
    "\n",
    "write_saotrace_lua(asolfile, asolh, evth)\n",
    "\n",
    "'''\n",
    "CXO time numbers are large and round-off error can appear\n",
    "which causes SAOTrace to fail.\n",
    "Therefore, shorten all times by about 0.01 sec to make sure.\n",
    "'''\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ba202ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(trace_nest +\n",
    "    f'tag=saotrace srcpars=saotrace_source.lua tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "09fe4ee6",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['OutputDir'] = 'marx_saotrace'\n",
    "pars['SourceType'] = 'SAOSAC'\n",
    "pars['SAOSACFile'] = 'saotrace.fits'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3511b998",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run('marx2fits --pixadj=EDSER marx_only marx_only.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx_saotrace marx_saotrace.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out3 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_only marx_only_rand.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out4 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_saotrace marx_saotrace_rand.fits', shell=True, \n",
    "                     capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b1996210",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Reprocess the observation with RANDOMIZE'''\n",
    "import ciao_contrib.runtool as rt\n",
    "rt.acis_process_events(infile=evt2file, outfile='obs_rand.fits', acaofffile=asolfile,\n",
    "                        doevtgrade=False, calculate_pi=False, apply_cti=False, pix_adj='RANDOMIZE', clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6ac4840f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from astropy.stats import sigma_clipped_stats\n",
    "from astropy.table import Table, Column\n",
    "import matplotlib.pyplot as plt\n",
    "\n",
    "# on import, this registers the plotting scale \"power\"\n",
    "import plot_utils\n",
    "\n",
    "def radial_distribution(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n",
    "    '''Calculate the radial distance from the mean position for events.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    x, y : np.array\n",
    "        x and y coordinates of events\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    r : np.array\n",
    "        radial distance from mean position of the events.\n",
    "    '''\n",
    "    centx = x - sigma_clipped_stats(x, sigma=1.5, maxiters=20)[0]\n",
    "    centy = y - sigma_clipped_stats(y, sigma=1.5, maxiters=20)[0]\n",
    "\n",
    "    xy = np.vstack([centx, centy])\n",
    "    return np.linalg.norm(xy, axis=0)\n",
    "\n",
    "\n",
    "def plot_ecf(ax:plt.Axes, \n",
    "             files: list[str], \n",
    "             filterargs: dict, \n",
    "             bgfilterargs: dict) -> tuple[float, float]:\n",
    "    '''\n",
    "    Parameters\n",
    "    ----------\n",
    "    ax : matplotlib axes\n",
    "        Axes where the plot will be placed\n",
    "    file : list\n",
    "        List of three strings with filename for observations,\n",
    "        Marx simulation, and SAOTRace + marx simulation\n",
    "    filterargs : dict\n",
    "        See ``filter_events`` for details\n",
    "    bgfilterargs : dict\n",
    "        Select a background region (same size, no automatic scaling)\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    err_marx : float\n",
    "        Flux error if the MARX simulated PSF is assumed to be right.\n",
    "        This is calculated as follows: We find the radius that encircles 90% of\n",
    "        all counts in the MARX simulation. Then, we extract the observed counts\n",
    "        using that radius. If the simulation is correct, that radius should\n",
    "        contain 90% of the observed counts, too. If, e.g. the simulated radius\n",
    "        is too small, we may extract only 80 % of the counts. The ratio between\n",
    "        the two would be 8/9=0.88, meaning that all fluxes extracted using\n",
    "        this radius are 12 % too small.\n",
    "    err_sao: float\n",
    "        Same for the simulation that used SAOTrace + MARX.\n",
    "    '''\n",
    "    # In this energy range we have the most counts and we limited\n",
    "    # the simulations to the same range.\n",
    "    obs = filter_events(Table.read(files[0], hdu=1), **filterargs)\n",
    "    bkg = filter_events(Table.read(files[0], hdu=1), **bgfilterargs)\n",
    "    r_obs = radial_distribution(obs['x'], obs['y'])\n",
    "    r_obs.sort()\n",
    "    ax.plot(r_obs, np.linspace(0, 1 + len(bkg) / len(r_obs), len(r_obs)),\n",
    "            label='Observation')\n",
    "\n",
    "    simmarx = filter_events(Table.read(files[1], hdu=1), **filterargs)\n",
    "    r_marx = radial_distribution(simmarx['X'], simmarx['Y'])\n",
    "    r_marx.sort()\n",
    "    ax.plot(r_marx, np.linspace(0, 1, len(r_marx)), label='MARX')\n",
    "\n",
    "    simsao = filter_events(Table.read(files[2], hdu=1), **filterargs)\n",
    "    r_sao = radial_distribution(simsao['X'], simsao['Y'])\n",
    "    r_sao.sort()\n",
    "    ax.plot(r_sao, np.linspace(0, 1, len(r_sao)), label='SAOTrace + MARX')\n",
    "\n",
    "    ax.set_xscale('power', power=0.5)\n",
    "    ax.set_xlabel('radius [pixel]')\n",
    "    ax.set_ylabel('enclosed count fraction')\n",
    "    ax.legend(loc='lower right')\n",
    "    ax.set_xticks([.1, .4, .7, 1, 2, 3, 4, 5])\n",
    "    ax.set_xlim([0.1, 5])\n",
    "    ax.set_ylim([0, 1.])\n",
    "\n",
    "    psf90_marx = np.percentile(r_marx, 90)\n",
    "    ecf_at_that_rad = np.argmin(np.abs(r_obs - psf90_marx)) / len(r_obs)\n",
    "    err_marx = ecf_at_that_rad / 0.9 - 1\n",
    "\n",
    "    psf90_sao = np.percentile(r_sao, 90)\n",
    "    ecf_at_that_rad = np.argmin(np.abs(r_obs - psf90_sao)) / len(r_obs)\n",
    "    err_sao = ecf_at_that_rad / 0.9 - 1\n",
    "\n",
    "    return err_marx, err_sao\n",
    "\n",
    "\n",
    "def colname_case(table: Table, name: str) -> Column:\n",
    "    '''Extract a column from a Table case insensitive to the column name.\n",
    "\n",
    "    If several columns in the table match ``name`` in a case-insensitive way,\n",
    "    this just returns the first match.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    table : `astropy.table.Table`\n",
    "        Table with columns\n",
    "    name : string\n",
    "        column name, case insensitive.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    col : `astropy.table.Column`\n",
    "        Table column\n",
    "    '''\n",
    "    for n in table.colnames:\n",
    "        if name.lower() == n.lower():\n",
    "            return table[n]\n",
    "    return table[name]\n",
    "\n",
    "\n",
    "def filter_events(evt: Table, \n",
    "                  circle: tuple | None = None, \n",
    "                  energy: tuple | None = None, \n",
    "                  time: tuple | None = None) -> Table:\n",
    "    '''A simple event filter function.\n",
    "\n",
    "    The parameters offer several filters, it set to ``None`` a filter is not\n",
    "    applied.\n",
    "    This simple function does not duplicate the entire CIAO syntax, only\n",
    "    a few simple filters useful for plotting in pure-python functions.\n",
    "\n",
    "    Parameters\n",
    "    ----------\n",
    "    evt : `astropy.table.Table`\n",
    "        Event table\n",
    "    circle : tuple or ``None``\n",
    "        Tuple of the form (x, y, r) where (x, y) is the center of\n",
    "        a circle and r the radius. All number are in detector coordinates.\n",
    "    energy : tuple or ``None``\n",
    "        Tuple of the form (lower, upper) with all energies in eV.\n",
    "    time : tuple or ``None``\n",
    "        Tuple of the form (star, end) with all times in seconds.\n",
    "\n",
    "    Returns\n",
    "    -------\n",
    "    evt_filt : ~astropy.table.Table`\n",
    "        Filtered event list\n",
    "    '''\n",
    "    if circle is not None:\n",
    "        d = np.sqrt((colname_case(evt, 'x') - circle[0])**2 + (colname_case(evt, 'y') - circle[1])**2)\n",
    "        indcirc = d < circle[2]\n",
    "    else:\n",
    "        indcirc = np.ones(len(evt), dtype=bool)\n",
    "\n",
    "    if energy is not None:\n",
    "        en = colname_case(evt, 'energy')\n",
    "        inden = (en > energy[0]) & (en < energy[1])\n",
    "    else:\n",
    "        inden = np.ones_like(indcirc)\n",
    "\n",
    "    if time is not None:\n",
    "        t = colname_case(evt, 'time')\n",
    "        indt = (t > time[0]) & (t < time[1])\n",
    "    else:\n",
    "        indt = np.ones_like(indcirc)\n",
    "\n",
    "    return evt[indcirc & inden & indt]\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4be2d4ae",
   "metadata": {},
   "outputs": [],
   "source": [
    "filterargs = {'energy': [300, 3000], 'circle': (x, y, 5 * r)}\n",
    "bgfilterargs = {'energy': [300, 3000], 'circle': (bg_x, bg_y, 5 * r)}\n",
    "\n",
    "fig, axes = plt.subplots(figsize=(6, 3), ncols=2)\n",
    "\n",
    "for ax, files, title in zip(axes,\n",
    "                            [[evt2file, 'marx_only.fits', 'marx_saotrace.fits'],\n",
    "                                ['obs_rand.fits', 'marx_only_rand.fits', 'marx_saotrace_rand.fits']],\n",
    "                            ['EDSER', 'RANDOMIZE']):\n",
    "    err_marx, err_sao = plot_ecf(ax, files, filterargs, bgfilterargs)\n",
    "\n",
    "    ax.set_title(title)\n",
    "    ax.grid()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dab8ec0f",
   "metadata": {},
   "source": [
    "Enclosed count fraction for observation and simulations. The simulations are run with a count number similar to the (fairly short) observation and thus there is some wiggling due to Poisson noise. On the left, the results using the default EDSER algorithms are shown, on the right, the sub-pixel positions are randomized within the pixel independent of the flight grade, which smooths out the inner PSF and hides the problem that marx does not make good predictions for the flight grades.\n",
    "\n",
    "For BI chips (here ACIS-S3) the marx simulated PSF is too narrow. This effect is most pronounced at small radii around 1 pixel. At larger radii the marx simulation comes closer to the observed distribution. Running the simulation with a combination of SAOTrace and marx gives PSF distributions that are closer to the observed numbers. However, in the range around 1 pix, the simulations are still too wide. Depending on the way sub-pixel information is handled, there is a notable difference in the size of the effect. Using energy-dependent sub-pixel event repositioning (EDSER) requires not only a good mirror model, but also a realistic treatment of the flight grades assigned on the detector. This is where the difference between simulation and observations is largest.\n",
    "\n",
    "The figures show that there are at least two factors contributing to the difference: The mirror model and problems in the simulation of the EDSER algorithm.\n",
    "\n",
    "**The put those numbers into perspective: If I used the marx simulation to determine the size of the extraction region that encloses 80% of all source counts, I would find a radius close to 0.9 pixel. However, in reality, such a region will only contain about 65% of all flux, causing me to underestimate the total X-ray flux in this source by 15%. (The exact number depends on the spectrum of the source in question.)**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "38ff655d",
   "metadata": {},
   "source": [
    "## On-axis PSF on an ACIS-FI chip\n",
    "Same as above for a FI chip. The target of this observations is tau Canis Majores."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "45b2d528",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Download data\n",
    "out = download_chandra_obsids([4469])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1c89a0a3",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolfile = '4469/primary/pcadf04469_000N001_asol1.fits.gz'\n",
    "evt2file = '4469/primary/acisf04469N004_evt2.fits.gz'\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b4c6ae2",
   "metadata": {},
   "outputs": [],
   "source": [
    "sky_coos = SkyCoord.from_name('tau Canis Majoris')\n",
    "coos = cel_to_chandra(fits.getheader(evt2file, 1), sky_coos.ra.degree, sky_coos.dec.degree)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "efb99a17",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = coos['x'][0]\n",
    "y = coos['y'][0]\n",
    "r = 4\n",
    "region = f'circle({x},{y},{r})'\n",
    "psffrac = 1.0\n",
    "\n",
    "bg_x = 4182\n",
    "bg_y = 4127"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "46476007",
   "metadata": {},
   "outputs": [],
   "source": [
    "write_spectrum_from_fluxcorrection(asolfile, evt2file, x, y, region, psffrac=psffrac)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "17dd8bc6",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['SpectrumType'] = 'FILE'\n",
    "pars['SpectrumFile'] = 'input_spec_marx.tbl'\n",
    "pars['OutputDir'] = 'marx_only'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "24b43dc9",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2400aca3",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolh = fits.getheader(asolfile, 1)\n",
    "evth = fits.getheader(evt2file, 1)\n",
    "write_saotrace_lua(asolfile, asolh, evth)\n",
    "\n",
    "'''\n",
    "CXO time numbers are large and round-off error can appear\n",
    "which make SAOTrace fail.\n",
    "Therefore, shorten all times by about 0.01 sec to make sure.\n",
    "'''\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d74263c5",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(trace_nest +\n",
    "    f'tag=saotrace srcpars=saotrace_source.lua tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "94eaf250",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars['OutputDir'] = 'marx_saotrace'\n",
    "pars['SourceType'] = 'SAOSAC'\n",
    "pars['SAOSACFile'] = 'saotrace.fits'\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "26b45701",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run('marx2fits --pixadj=EDSER marx_only marx_only.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx_saotrace marx_saotrace.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out3 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_only marx_only_rand.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out4 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_saotrace marx_saotrace_rand.fits', shell=True, \n",
    "                     capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "11e3d75a",
   "metadata": {},
   "outputs": [],
   "source": [
    "rt.acis_process_events(infile=evt2file, outfile='obs_rand.fits', acaofffile=asolfile,\n",
    "                        doevtgrade=False, calculate_pi=False, apply_cti=False, pix_adj='RANDOMIZE', clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "36534066",
   "metadata": {},
   "outputs": [],
   "source": [
    "filterargs = {'energy': [300, 3000], 'circle': (x, y, 5 * r)}\n",
    "bgfilterargs = {'energy': [300, 3000], 'circle': (bg_x, bg_y, 5 * r)}\n",
    "\n",
    "\n",
    "fig, axes = plt.subplots(figsize=(8, 4), ncols=2)\n",
    "\n",
    "for ax, files, title in zip(axes,\n",
    "                            [[evt2file, 'marx_only.fits', 'marx_saotrace.fits'],\n",
    "                                ['obs_rand.fits', 'marx_only_rand.fits', 'marx_saotrace_rand.fits']],\n",
    "                            ['EDSER', 'RANDOMIZE']):\n",
    "    err_marx, err_sao = plot_ecf(ax, files, filterargs, bgfilterargs)\n",
    "\n",
    "    ax.set_title(title)\n",
    "    ax.grid()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "eaca0fcb",
   "metadata": {},
   "source": [
    "Enclosed count fraction for observation and simulations in the same format as above, but for an ACIS-I observation.\n",
    "\n",
    "As for the BI chip, marx simulations indicate a PSF that is narrower than the observed distribution. Using SAOTrace as a mirror model, gives better results but still differs significantly from the observed distribution."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "631896de",
   "metadata": {},
   "source": [
    "## On-axis PSF for an HRC-I observation\n",
    "Same as above for an HRC-I observations of AR Lac.\n",
    "\n",
    "Since the HRC has no intrinsic energy resolution, the source spectrum\n",
    "can not be taken from the observed data. Instead, we fitted a model\n",
    "to a grating spectrum of the same source and saved that model\n",
    "spectrum to a file. AR Lac is known to be time variable and to show\n",
    "stellar flares, so this spectrum is only an approximation, but it\n",
    "is the best we can do here."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ad8e3f04",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Download data\n",
    "out = download_chandra_obsids([13182])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e96a9486",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolfile = '13182/primary/pcadf13182_000N001_asol1.fits.gz'\n",
    "evt2file = '13182/primary/hrcf13182N004_evt2.fits.gz'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "39639691",
   "metadata": {},
   "outputs": [],
   "source": [
    "sky_coos = SkyCoord.from_name('AR Lac')\n",
    "coos = cel_to_chandra(fits.getheader(evt2file, 1), sky_coos.ra.degree, sky_coos.dec.degree)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "345c03c3",
   "metadata": {},
   "outputs": [],
   "source": [
    "x, y = coos['x'][0], coos['y'][0]\n",
    "r = 15\n",
    "region = f'circle({x},{y},{r})'\n",
    "psffrac = 1.0\n",
    "\n",
    "bg_x, bg_y = 16043, 16700"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e811afee",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['SpectrumType'] = 'FILE'\n",
    "pars['SpectrumFile'] = 'data/ARLac_input_spec_marx.tbl'\n",
    "pars['OutputDir'] = 'marx_only'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f5ae99b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "marxcall"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6a482af9",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolh = fits.getheader(asolfile, 1)\n",
    "evth = fits.getheader(evt2file, 1)\n",
    "write_saotrace_lua(asolfile, asolh, evth, spectrumfile='data/ARLac_input_spec_saotrace.rdb')\n",
    "\n",
    "'''\n",
    "CXO time numbers are large and round-off error can appear\n",
    "which make SAOTrace fail.\n",
    "Therefore, shorten all times by about 0.01 sec to make sure.\n",
    "'''\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dc9dc950",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(trace_nest +\n",
    "    f'tag=saotrace srcpars=saotrace_source.lua tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "06aaeb02",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars['OutputDir'] = 'marx_saotrace'\n",
    "pars['SourceType'] = 'SAOSAC'\n",
    "pars['SAOSACFile'] = 'saotrace.fits'\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f3bda63",
   "metadata": {},
   "outputs": [],
   "source": [
    "# HRC does not record grade information, so EDSER is not applicable\n",
    "out3 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_only marx_only.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out4 = subprocess.run('marx2fits --pixadj=RANDOMIZE marx_saotrace marx_saotrace.fits', shell=True, \n",
    "                     capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "42d036d3",
   "metadata": {},
   "outputs": [],
   "source": [
    "filterargs = {'circle': (x, y, 5 * r)}\n",
    "bgfilterargs =  {'circle': (bg_x, bg_y, 5 * r)}\n",
    "files = [evt2file, 'marx_only.fits', 'marx_saotrace.fits']\n",
    "\n",
    "fig, ax = plt.subplots()\n",
    "\n",
    "err_marx, err_sao = plot_ecf(ax, files, filterargs, bgfilterargs)\n",
    "ax.set_xlim([0, 20.])\n",
    "ax.grid()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f7995e63",
   "metadata": {},
   "source": [
    "Enclosed count fraction for observation and simulations.\n",
    "\n",
    "The PSF predicted by SAOTrac + marx tracks the general shape pf the observed PSF well, though differences are apparent in the core and in the wings. Like in ACIS, the PSF simulated with marx alone is narrower than the observed PSF."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2acc6b0e",
   "metadata": {},
   "source": [
    "## Off-axis PSF\n",
    "For an off-axis source the differences between detector pixel size and different\n",
    "event repositioning algorithms is not important any longer. Instead, the size of\n",
    "the PSF is dominated by optics errors because the detector plane deviates from\n",
    "the curved focal plane and because a Wolter type I optic has fundamental limitations\n",
    "for off-axis sources.\n",
    "\n",
    "The PSF is much larger no longer circular. As this test shows, the shadows of\n",
    "the support struts become visible.\n",
    "   "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "002608de",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = download_chandra_obsids([1068])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4c84bf14",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolfile = '1068/primary/pcadf01068_000N001_asol1.fits.gz'\n",
    "evt2file = '1068/primary/acisf01068N004_evt2.fits.gz'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6bf54f52",
   "metadata": {},
   "outputs": [],
   "source": [
    "x, y = 5246, 6890\n",
    "r = 200\n",
    "region = f'circle({x},{y},{r})'\n",
    "psffrac = 1.0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5605c7ce",
   "metadata": {},
   "outputs": [],
   "source": [
    "write_spectrum_from_fluxcorrection(asolfile, evt2file, x, y, region, psffrac=psffrac)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82d31139",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['SpectrumType'] = 'FILE'\n",
    "pars['SpectrumFile'] = 'input_spec_marx.tbl'\n",
    "pars['OutputDir'] = 'marx_only'\n",
    "pars['SourceFlux'] = -1\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2e621b04",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolh = fits.getheader(asolfile, 1)\n",
    "evth = fits.getheader(evt2file, 1)\n",
    "write_saotrace_lua(asolfile, asolh, evth)\n",
    "\n",
    "'''\n",
    "CXO time numbers are large and round-off error can appear\n",
    "which make SAOTrace fail.\n",
    "Therefore, shorten all times by about 0.01 sec to make sure.\n",
    "'''\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a1e27930",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(trace_nest +\n",
    "    f'tag=saotrace srcpars=saotrace_source.lua tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9ed2251",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars['OutputDir'] = 'marx_saotrace'\n",
    "pars['SourceType'] = 'SAOSAC'\n",
    "pars['SAOSACFile'] = 'saotrace.fits'\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ee9f9e25",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run('marx2fits --pixadj=EDSER marx_only marx_only.fits', shell=True, \n",
    "                     capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER marx_saotrace marx_saotrace.fits', shell=True, \n",
    "                     capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a8fe0f52",
   "metadata": {},
   "outputs": [],
   "source": [
    "from astropy.visualization import LogStretch\n",
    "from astropy.visualization.mpl_normalize import ImageNormalize\n",
    "import pycrates\n",
    "\n",
    "\n",
    "fig, axes = plt.subplots(1, 3, figsize=(10,6), subplot_kw={'aspect':'equal'})\n",
    "for ax, src, title in zip(axes.flatten(), \n",
    "                   [evt2file, \"marx_only.fits\", \"marx_saotrace.fits\"],\n",
    "                   ['Observation', 'MARX only', 'SAOTrace + MARX']):\n",
    "    evt = pycrates.read_file(src)\n",
    "    out = ax.hist2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                    bins=[400, 300], range=[[x-200,x+200], [y-150,y+150]],\n",
    "                    norm=ImageNormalize(stretch=LogStretch(), vmin=1, vmax=20))\n",
    "    out = ax.set_title(title)\n",
    "    ax.set_axis_off()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "50ebec98",
   "metadata": {},
   "source": [
    "The structure of the PSFs is very similar, emphasizing how good both mirror\n",
    "models are. On closer inspection, there is a small shadow just above and to the\n",
    "right of the point where the support strut shadows meet. This feature is a\n",
    "little smaller in marx than in SAOTrace or the real data due to the\n",
    "simplification that the marx mirror model makes."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1090aeb",
   "metadata": {},
   "source": [
    "## On-axis PSF at different energies\n",
    "The gold standard to test the fidelity of marx and SAOTrace\n",
    "obviously is to compare simulations to observations.\n",
    "However, it is also instructive to look at a few idealized cases with no\n",
    "observational counterpart so we can simulate high fidelity PSFs with a\n",
    "large number of counts without worrying about background or pile-up.\n",
    "The [Chandra Proposers Observatory Guide](http://cxc.harvard.edu/proposer/POG/html/chap4.html#tth_sEc4.2.3).\n",
    "contains a long section on the PSF and encircled energy based on SAOTrace\n",
    "simulations. Some of those simulations are repeated here to compare them\n",
    "to pure marx simulations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "79508c2c",
   "metadata": {},
   "outputs": [],
   "source": [
    "energy = [0.25, 0.5, 1, 2, 3, 4, 6, 8]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9c67a551",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Default marx settings for all simulations\n",
    "default_marx ='GratingType=NONE DetectorType=HRC-I ' + \\\n",
    "              'ExposureTime=10000 ' + \\\n",
    "              'SourceRA=0. SourceDEC=0. ' + \\\n",
    "              'RA_Nom=0. Dec_Nom=0. Roll_Nom=0. '"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f7c9fb9c",
   "metadata": {},
   "outputs": [],
   "source": [
    "import subprocess\n",
    "for e in energy:\n",
    "    out = subprocess.run(f'marx MinEnergy={e} MaxEnergy={e} DitherModel=INTERNAL OutputDir=\"marx_{e}\" ' +\n",
    "                    # Higher energies have larger PSF and thus need more photons to plot smooth\n",
    "                    # contours. This scaling is a compromise between runtime and looking good.\n",
    "                         f'SourceFlux={0.01*np.sqrt(e)} ' + \n",
    "                     default_marx, shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=NONE marx_{e} marx{e}.fits', \n",
    "                          shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a745669d",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Generate asol file\n",
    "\n",
    "Since all simulations use the same pointing and exposure time, it is\n",
    "enough to run `marxasp` once.\n",
    "'''\n",
    "out = subprocess.run(f'marxasp MarxDir=\"marx_{energy[0]}\" ',\n",
    "                     shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "436ec054",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolh = fits.getheader('sim_asol.fits', 1)\n",
    "\n",
    "limit = asolh['TSTOP'] - asolh['TSTART']\n",
    "limit = limit - 0.02\n",
    "\n",
    "\n",
    "for e in energy:\n",
    "    lua_text = f'''\n",
    "point{{ position = {{ ra = 0.,\n",
    "        dec = 0.,\n",
    "        ra_aimpt = 0.,\n",
    "        dec_aimpt = 0.,\n",
    "        }},\n",
    "        spectrum = {{ {{ {e}, {0.01 * np.sqrt(e)} }} }} \n",
    "    }}\n",
    "roll(0)\n",
    "dither_asol_chandra{{ file = \"sim_asol.fits\", ra = 0., dec = 0., roll = 0. }}\n",
    "'''\n",
    "    with open('saotrace_source.lua', 'w') as f:\n",
    "        f.write(lua_text)\n",
    "    subprocess.run(trace_nest +\n",
    "                   f'tag=sao{e} srcpars=saotrace_source.lua ' +\\\n",
    "                   f'tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6ab5d59",
   "metadata": {},
   "outputs": [],
   "source": [
    "for e in energy:\n",
    "    out = subprocess.run(f'marx SourceType=SAOSAC SAOSACFile=\"sao{e}.fits\" DitherModel=FILE DitherFile=\"sim_asol.fits\" OutputDir=\"saomarx_{e}\" ' +\n",
    "                     default_marx, shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=NONE saomarx_{e} saomarx_{e}.fits', \n",
    "                          shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6c314ebd",
   "metadata": {},
   "outputs": [],
   "source": [
    "from mpl_toolkits.axes_grid1 import AxesGrid\n",
    "from matplotlib.ticker import StrMethodFormatter, FuncFormatter\n",
    "\n",
    "fig = plt.figure(figsize=(10, 4))\n",
    "\n",
    "grid = AxesGrid(fig, 111,  # similar to subplot(142)\n",
    "                nrows_ncols=(2, len(energy)),\n",
    "                axes_pad=0.0,\n",
    "                share_all=True,\n",
    "                label_mode=\"L\",\n",
    "                cbar_location=\"top\",\n",
    "                cbar_mode=\"single\"\n",
    "                )\n",
    "\n",
    "for i, e in enumerate(energy):\n",
    "\n",
    "    for prog in ['marx', 'saomarx_']:\n",
    "        f = f'{prog}{e}.fits'\n",
    "        offset = 0 if prog == 'marx' else len(energy)\n",
    "        \n",
    "        with fits.open(f) as hdus:\n",
    "            header = hdus[1].header\n",
    "        tab = Table.read(f, hdu=1)\n",
    "        # The old question: Is an index the center of a pixel or the corner?\n",
    "        # Differs by 0.5...\n",
    "        d_ra = (tab['X'] - header['TCRPX9'] - 0.5) * header['TCDLT9'] * 3600.\n",
    "        # And do I count from the left or right (RA is reversed on the sky)?\n",
    "        d_dec = (tab['Y'] - header['TCRPX10'] + 0.5) * header['TCDLT10'] * 3600.\n",
    "\n",
    "        im = grid[i + offset].hist2d(d_ra, d_dec,\n",
    "                                        range=[[-1, 1], [-1, 1]],\n",
    "                                        bins=[20, 20],\n",
    "                                        cmap=plt.get_cmap('OrRd'))\n",
    "        levels = np.max(im[0]) * np.array([0.3, 0.6, 0.9])\n",
    "        grid[i + offset].contour(0.5 * (im[1][1:] + im[1][:-1]),\n",
    "                                    0.5 * (im[2][1:] + im[2][:-1]),\n",
    "                                    # for some reason, the data is\n",
    "                                    # ordered for other orientation\n",
    "                                    im[0].T, levels=levels, colors='k') #,\n",
    "                                    #origin=im[3].origin)\n",
    "        grid[i + offset].grid()\n",
    "        if prog == 'marx':\n",
    "            grid[i].text(-.5, .5, '{0} keV'.format(e))\n",
    "        else:\n",
    "            grid[i].xaxis.set_major_formatter(StrMethodFormatter('{x:2.1g}'))\n",
    "\n",
    "grid[0].yaxis.set_major_formatter(StrMethodFormatter('{x:2.1g}'))\n",
    "grid[len(energy)].yaxis.set_major_formatter(StrMethodFormatter('{x:2.1g}'))\n",
    "cbar = grid.cbar_axes[0].colorbar(im[3],\n",
    "             format=FuncFormatter(lambda x, pos: ''))\n",
    "\n",
    "# This affects all axes as share_all = True.\n",
    "grid.axes_llc.set_xticks([-.5, 0, .5])\n",
    "grid.axes_llc.set_yticks([-.5, 0, .5])\n",
    "\n",
    "grid[0].set_ylabel('Marx')\n",
    "grid[offset].set_ylabel('Marx +\\nSAOTrace')\n",
    "grid[int(1.5 * offset)].set_xlabel('arcsec (measured from nominal source position)')\n",
    "\n",
    "fig.subplots_adjust(top=1, bottom=0, left=0.1, right=0.99)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "619ff759",
   "metadata": {},
   "source": [
    "PSF images for different discrete energies for pure marx and SAOTrace + marx simulations. The color scale is linear, but the absolute scaling is different for different images, because the effective area and thus the number of detected photons is lower at higher energies. Contour lines mark flux levels at 30%, 60%, and 90% of the peak flux level. At higher energies, the PSF becomes asymmetric, because mirror pair 6, which is most important at high energies, is slightly tilted with respect to the nominal aimpoint. At the same time, the scatter, and thus the size of the PSF, increase at higher energies.\n",
    "\n",
    "Because the simulations are done with Monte-Carlo methods and the number of photons simulated is finite (but large compared to typical observations), there is some noise in the images. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f7c561d",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize=(7, 4))\n",
    "axecf = fig.add_subplot(111)\n",
    "color = plt.cm.jet_r(np.linspace(0, 1, len(energy)))\n",
    "for i, e in enumerate(energy):\n",
    "\n",
    "    for prog in ['marx', 'saomarx_']:\n",
    "        f = f'{prog}{e}.fits'\n",
    "        with fits.open(f) as hdus:\n",
    "            header = hdus[1].header\n",
    "\n",
    "        tab = Table.read(f, hdu=1)\n",
    "        # The old question: Is an index the center of a pixel of the corner?\n",
    "        # Differs by 0.5...\n",
    "        d_ra = (tab['X'] - header['TCRPX9'] - 0.5) * header['TCDLT9'] * 3600.\n",
    "        # Count from the left or right (RA is reversed on the sky)?\n",
    "        d_dec = (tab['Y'] - header['TCRPX10'] + 0.5) * header['TCDLT10'] * 3600.\n",
    "\n",
    "        # The simulation is set up to make this simple: RA=DEC=0\n",
    "        # so cos(DEC) = 1 and we can approximate with Euklidian distance\n",
    "        r = np.linalg.norm(np.vstack([d_ra, d_dec]), axis=0)\n",
    "        val, edges = np.histogram(r, range=[0, 5], bins=50)\n",
    "        bin_mid_marx = 0.5 * (edges[:-1] + edges[1:])\n",
    "        ecf_marx = 1.0 * val.cumsum() / val.sum()\n",
    "        if prog == 'marx':\n",
    "            line, = axecf.plot(bin_mid_marx, ecf_marx, color=color[i],\n",
    "                                label='{0} keV'.format(e))\n",
    "        else:\n",
    "            axecf.plot(bin_mid_marx, ecf_marx, color=line.get_color(), ls=':')\n",
    "axecf.set_xscale('power', power=0.5)\n",
    "axecf.legend(loc='lower right')\n",
    "axecf.set_ylabel('encircled count fraction')\n",
    "axecf.set_xlabel('radius [arcsec]')\n",
    "axecf.set_xticks([0, .1, .2, .4, .6, .8, 1, 2, 3, 4, 5])\n",
    "axecf.grid()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a4534737",
   "metadata": {},
   "source": [
    "A different way to present the width of the PSF is the encircled count fraction. For each photon, the radial distance is calculated from the nominal source position. Because the center is offset for hard photons, the PSF appears wider at those energies.\n",
    "**solid line**: marx only, **dotted lines**: SAOTrace + marx.\n",
    "\n",
    "\n",
    "marx and SAOTrace simulations predict a very similar PSF shape, but for most energies the SAOTrace model predicts a slightly broader PSF."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8f8839a5",
   "metadata": {},
   "source": [
    "## Simulated off-axis PSF\n",
    "Compare marx and SAOTrace + marx simulations for different\n",
    "off-axis angles. For simplicity, this is done here for a single energy.\n",
    "We pick 4 keV because it is roughly the center of the Chandra band."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a900d5c",
   "metadata": {},
   "outputs": [],
   "source": [
    "off_axis_angle = [0, .5, 1, 2, 3, 5, 7, 10, 15]  # in arcmin"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c15ccb4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Default marx settings for all simulations\\\n",
    "default_marx ='GratingType=NONE DetectorType=HRC-I ' + \\\n",
    "              'ExposureTime=10000 SourceDEC=0. ' + \\\n",
    "              'RA_Nom=0. Dec_Nom=0. Roll_Nom=0. ' + \\\n",
    "              'MinEnergy=4 MaxEnergy=4 SourceFlux=0.01 '"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5890b5d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import subprocess\n",
    "for a in off_axis_angle:\n",
    "    out = subprocess.run(f'marx DitherModel=INTERNAL OutputDir=\"marx_{a}\" ' +\n",
    "                         f'SourceRA={a / 60.} ' +\n",
    "                     default_marx, shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=NONE marx_{a} marx{a}.fits', \n",
    "                          shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "745d0ba8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# We can reuse the asol file from above since we set up the same pointing, so the\n",
    "# variable asolh, limit are still valid.\n",
    "for a in off_axis_angle:\n",
    "    lua_text = f'''\n",
    "point{{ position = {{ ra = {a / 60.},\n",
    "        dec = 0.,\n",
    "        ra_aimpt = 0.,\n",
    "        dec_aimpt = 0.,\n",
    "        }},\n",
    "        spectrum = {{ {{ 4, 0.01 }} }} \n",
    "    }}\n",
    "roll(0)\n",
    "dither_asol_chandra{{ file = \"sim_asol.fits\", ra = 0., dec = 0., roll = 0. }}\n",
    "'''\n",
    "    with open('saotrace_source.lua', 'w') as f:\n",
    "        f.write(lua_text)\n",
    "    subprocess.run(trace_nest +\n",
    "                   f'tag=sao{a} srcpars=saotrace_source.lua ' +\\\n",
    "                   f'tstart={asolh[\"TSTART\"] + 0.01} limit={limit} limit_type=sec', shell=True)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dabcb9b9",
   "metadata": {},
   "outputs": [],
   "source": [
    "for a in off_axis_angle:\n",
    "    out = subprocess.run(f'marx SourceType=SAOSAC SAOSACFile=\"sao{a}.fits\" DitherModel=FILE DitherFile=\"sim_asol.fits\" OutputDir=\"saomarx_{a}\" ' + \n",
    "        # The following line is needed because of https://github.com/Chandra-MARX/marx/issues/83\n",
    "                         'SourceRA={0} '.format(a / 60.) +\n",
    "                         default_marx, shell=True, capture_output=True)\n",
    "    out2 = subprocess.run(f'marx2fits --pixadj=NONE saomarx_{a} saomarx_{a}.fits', \n",
    "                          shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "be2910ca",
   "metadata": {},
   "outputs": [],
   "source": [
    "ecf = [0.5, 0.7, 0.9]\n",
    "fig, axecf = plt.subplots()\n",
    "out = np.zeros((len(off_axis_angle), 2, len(ecf)))\n",
    "\n",
    "for i, a in enumerate(off_axis_angle):\n",
    "    for prog in ['marx', 'saomarx_']:\n",
    "        f = f'{prog}{a}.fits'\n",
    "        with fits.open(f) as hdus:\n",
    "            header = hdus[1].header\n",
    "        tab = Table.read(f, hdu=1)\n",
    "        # The old question: Is an index the center of a pixel of the corner?\n",
    "        # Differs by 0.5...\n",
    "        d_ra = (tab['X'] - header['TCRPX9'] - 0.5) * header['TCDLT9'] * 3600.\n",
    "        # Count from the left or right (RA is reversed on the sky)?\n",
    "        d_dec = (tab['Y'] - header['TCRPX10'] + 0.5) * header['TCDLT10'] * 3600.\n",
    "\n",
    "        # The simulation is set up to make this simple: RA=DEC=0\n",
    "        # so cos(DEC) = 1 and we can approximate with Euklidian distance\n",
    "        r = radial_distribution(d_ra, d_dec)\n",
    "        out[i, 0 if prog == 'marx' else 1, :] = np.percentile(r, np.array(ecf) * 100.)\n",
    "\n",
    "for i, e in enumerate(ecf):\n",
    "    line, = axecf.plot(off_axis_angle, out[:, 0, i],\n",
    "                        label='{0} %'.format(e*100))\n",
    "    axecf.plot(off_axis_angle, out[:, 1, i], color=line.get_color(),\n",
    "                ls=':')\n",
    "axecf.legend(loc='lower right')\n",
    "axecf.set_ylabel('radius [arcsec]')\n",
    "axecf.set_xlabel('off-axis angle [arcmin]')\n",
    "axecf.grid()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b665d917",
   "metadata": {},
   "source": [
    "Radius of encircled count fraction for different off-axis angles. The values shown include the effect of the HRC-I positional uncertainty and the uncertainty in the aspect solution. **solid line**: marx only, **dotted lines**: SAOTrace + marx\n",
    "\n",
    "Both simulations show essentially identical off-axis behavior in this test."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ciao-4.18.b2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
