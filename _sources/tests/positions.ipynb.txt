{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6b72e1a",
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import setup_marx\n",
    "setup_marx()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "594828cc",
   "metadata": {},
   "source": [
    "# Coordinates on the sky and the chip\n",
    "In every marx simulation, one or more sources are placed at some sky position.\n",
    "marx simulates photons coming from that position, traces them through the\n",
    "mirror and gratings and finally places them on the chip. With a known\n",
    "aspect solution, chip coordinates can then be transformed back to sky\n",
    "coordinates. In general, this will not recover the exact sky position where a\n",
    "photon started out. A big part of that is scatter in the mirrors, which blurs\n",
    "the image.\n",
    "However, with a large number of photons, we can fit the average position which\n",
    "should be close to the real sky position.\n",
    "\n",
    "In real observations, other factors contribute, such as the finite\n",
    "resolution of the detectors (marx usually takes that into account, but it can\n",
    "be switched off through the ``--pixadj=\"EXACT\"`` switch in `marx2fits`)\n",
    "and the uncertainty of the aspect solution.\n",
    "\n",
    "Within a single observation, positions will be less certain for fainter sources\n",
    "(due to Poisson statistics) and for sources at a larger off-axis angles (due to the\n",
    "larger PSF)."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ecaa249d",
   "metadata": {},
   "source": [
    "## Chandra Orion Ultradeep project\n",
    "The [Orion Nebula Cluster (ONC)](http://simbad.u-strasbg.fr/simbad/sim-basic?Ident=onc)\n",
    "is a dense star forming region with about 1600 X-ray sources observed\n",
    "in the COUP survey by\n",
    "[Getman et al (2005)](http://adsabs.harvard.edu/abs/2005ApJS..160..319G).\n",
    "We simulate this field with marx and then run a source detection to check\n",
    "how well we recover the input coordinates. This will depend on the number\n",
    "of counts detected and the position in the field.\n",
    "To simplify the simulation input, we assume that all sources have flat\n",
    "lightcurves and are monoenergetic at the observed mean energy (the energy matters because\n",
    "the effective area is energy dependent and so is the PSF).\n",
    "We write a short C code that reads an input coordinate list and generates the photons in this manner."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f547050e",
   "metadata": {},
   "outputs": [],
   "source": [
    "from ciao_contrib.cda.data import download_chandra_obsids"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "266d0960",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = download_chandra_obsids([3744], filetypes=['asol', 'evt2'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4598650",
   "metadata": {},
   "outputs": [],
   "source": [
    "asolfile = '3744/primary/pcadf03744_000N001_asol1.fits.gz'\n",
    "evt2file = '3744/primary/acisf03744N004_evt2.fits.gz'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8e7bd9ec",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Make input coordinate table\n",
    "\n",
    "- Coordinates are relative to pointing direction in arcmin\n",
    "- weight is a measure for the fraction on photons coming from that source, i.e. a linear luminosity\n",
    "- For the source spectrum, we just take a mono-energetic source with the average energy.\n",
    "'''\n",
    "import os\n",
    "from astropy.table import Table\n",
    "from astropy.io import fits\n",
    "\n",
    "asol = fits.getheader(asolfile, 1)\n",
    "coup = Table.read(os.path.join('data', 'COUP.tsv'), format='ascii.fast_tab')\n",
    "tab = Table()\n",
    "tab['RA'] = (coup['RAJ2000'] - asol['RA_NOM']) * 60\n",
    "tab['DEC'] = (coup['DEJ2000'] - asol['DEC_NOM']) * 60\n",
    "tab['weight'] = 10**(coup['Lt'] - 27)\n",
    "tab['energy'] = coup['<E>']\n",
    "tab.write('coup.marxin', format='ascii.no_header', overwrite=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e5735a72",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''C code for a grid of sources.\n",
    "\n",
    "(``user.h`` and ``jdmath.h`` are shipped with marx.)'''\n",
    "ccode=r'''\n",
    "#include <stdio.h>\n",
    "#include <stdlib.h>\n",
    "#include <jdmath.h>\n",
    "#include \"user.h\"\n",
    "\n",
    "/* This user source implements many point sources via a file that\n",
    " * specifies the source positions and energies.  The current implementation\n",
    " * assumes the format:\n",
    " *  RA  Dec weight energy\n",
    " * Here RA, Dec specify the source position, weight specifies the strength\n",
    " * of the source in relation to the others.\n",
    " */\n",
    "typedef struct\n",
    "{\n",
    "   double cosx, cosy, cosz;\n",
    "   double weight;\n",
    "   double energy;\n",
    "}\n",
    "Point_Source_Type;\n",
    "\n",
    "static unsigned int Num_Points;\n",
    "static Point_Source_Type *Point_Sources;\n",
    "static unsigned int Max_Num_Points;\n",
    "\n",
    "static char *do_realloc (char *p, unsigned int len)\n",
    "{\n",
    "   if (p == NULL)\n",
    "     p = malloc (len);\n",
    "   else\n",
    "     p = realloc (p, len);\n",
    "\n",
    "   if (p == NULL)\n",
    "     fprintf (stderr, \"Not enough memory\\n\");\n",
    "\n",
    "   return p;\n",
    "}\n",
    "\n",
    "static void free_sources (void)\n",
    "{\n",
    "   if (Point_Sources == NULL)\n",
    "     return;\n",
    "\n",
    "   free ((char *) Point_Sources);\n",
    "   Point_Sources = NULL;\n",
    "}\n",
    "\n",
    "static int add_source (double ra, double dec, double weight, double energy)\n",
    "{\n",
    "   Point_Source_Type *p;\n",
    "   double cosx, cosy, cosz;\n",
    "\n",
    "   /* Convert to God's units from arc-min */\n",
    "   ra = ra * (PI/(180.0 * 60.0));\n",
    "   dec = dec * (PI/(180.0 * 60.0));\n",
    "\n",
    "   if (Max_Num_Points == Num_Points)\n",
    "     {\n",
    "        Max_Num_Points += 32;\n",
    "        p = (Point_Source_Type *)do_realloc ((char *)Point_Sources, Max_Num_Points * sizeof (Point_Source_Type));\n",
    "        if (p == NULL)\n",
    "          {\n",
    "             free_sources ();\n",
    "             return -1;\n",
    "          }\n",
    "        Point_Sources = p;\n",
    "     }\n",
    "\n",
    "   p = Point_Sources + Num_Points;\n",
    "   /* Note the the minus sign is to generate a vector pointing from the\n",
    "    * source to the origin\n",
    "    */\n",
    "   p->cosx = -cos (dec) * cos (ra);\n",
    "   p->cosy = -cos (dec) * sin(ra);\n",
    "   p->cosz = -sin (dec);\n",
    "\n",
    "   p->weight = weight;\n",
    "   p->energy = energy;\n",
    "   Num_Points += 1;\n",
    "\n",
    "   return 0;\n",
    "}\n",
    "\n",
    "static void normalize_sources (void)\n",
    "{\n",
    "   double total;\n",
    "   unsigned int i;\n",
    "\n",
    "   total = 0;\n",
    "   for (i = 0; i < Num_Points; i++)\n",
    "     {\n",
    "\tPoint_Sources[i].weight += total;\n",
    "\ttotal = Point_Sources[i].weight;\n",
    "     }\n",
    "\n",
    "   for (i = 0; i < Num_Points; i++)\n",
    "     Point_Sources[i].weight /= total;\n",
    "\n",
    "   /* Make sure no round-off error affects the weight of the last point */\n",
    "   Point_Sources[Num_Points - 1].weight = 1.0;\n",
    "}\n",
    "\n",
    "int user_open_source (char **argv, int argc, double area,\n",
    "\t\t      double cosx, double cosy, double cosz)\n",
    "{\n",
    "   FILE *fp;\n",
    "   char line[1024];\n",
    "   char *file;\n",
    "   unsigned int linenum;\n",
    "\n",
    "   file = argv[0];\n",
    "   if (file == NULL)\n",
    "     {\n",
    "\tfprintf (stderr, \"UserSource Model requires FILE as argument\\n\");\n",
    "\treturn -1;\n",
    "     }\n",
    "\n",
    "   fp = fopen (file, \"r\");\n",
    "   if (fp == NULL)\n",
    "     {\n",
    "\tfprintf (stderr, \"Unable to open %s\\n\", file);\n",
    "\treturn -1;\n",
    "     }\n",
    "\n",
    "   linenum = 0;\n",
    "   while (NULL != fgets (line, sizeof (line), fp))\n",
    "     {\n",
    "\tdouble ra, dec, weight, energy;\n",
    "\n",
    "\tlinenum++;\n",
    "\tif (4 != sscanf (line, \"%lf %lf %lf %lf\", &ra, &dec, &weight, &energy))\n",
    "\t  continue;\n",
    "\n",
    "\tif (weight <= 0.0)\n",
    "\t  {\n",
    "\t     fprintf (stderr, \"weight on line %d of %s must be positive\\n\",\n",
    "\t\t      linenum, file);\n",
    "\t     free_sources ();\n",
    "\t     return -1;\n",
    "\t  }\n",
    "\n",
    "\tif (-1 == add_source (ra, dec, weight, energy))\n",
    "\t  {\n",
    "\t     fclose (fp);\n",
    "\t     return -1;\n",
    "\t  }\n",
    "     }\n",
    "\n",
    "   fclose (fp);\n",
    "   if (Num_Points == 0)\n",
    "     {\n",
    "\tfprintf (stderr, \"%s contains no sources\\n\", file);\n",
    "\treturn -1;\n",
    "     }\n",
    "\n",
    "   normalize_sources ();\n",
    "   return 0;\n",
    "}\n",
    "\n",
    "void user_close_source (void)\n",
    "{\n",
    "   free_sources ();\n",
    "}\n",
    "\n",
    "\n",
    "int user_create_ray (double *delta_t, double *energy,\n",
    "\t\t     double *cosx, double *cosy, double *cosz)\n",
    "{\n",
    "   double r;\n",
    "   Point_Source_Type *p;\n",
    "\n",
    "   p = Point_Sources;\n",
    "\n",
    "   r = JDMrandom ();\n",
    "   while (r > p->weight)\n",
    "     p++;\n",
    "\n",
    "   *delta_t = -1.0;\n",
    "   *energy = p->energy;\n",
    "   *cosx = p->cosx;\n",
    "   *cosy = p->cosy;\n",
    "   *cosz = p->cosz;\n",
    "\n",
    "   return 0;\n",
    "}\n",
    "\n",
    "int main (int a, char **b)\n",
    "{\n",
    "   (void) a;\n",
    "   (void) b;\n",
    "   return 1;\n",
    "}\n",
    "'''\n",
    "\n",
    "with open('pnts.c', 'w') as f:\n",
    "    f.write(ccode)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27ea810f",
   "metadata": {},
   "outputs": [],
   "source": [
    "import shutil\n",
    "import subprocess\n",
    "\n",
    "marxpath = os.path.dirname(shutil.which('marx'))\n",
    "src = os.path.join(marxpath, '..',\n",
    "                    'share', 'doc', 'marx', 'examples', 'user-source')\n",
    "shutil.copy(os.path.join(src, 'user.h'), 'user.h')\n",
    "jdmath_h = os.path.join(marxpath, '..', 'include')\n",
    "jdmath_a = os.path.join(marxpath, '..', 'lib', 'libjdmath.a')\n",
    "\n",
    "out = subprocess.run(['gcc', '-I' + jdmath_h, jdmath_a,\n",
    "                      '-shared', 'pnts.c', '-o', 'pnts.so'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0cbae455",
   "metadata": {},
   "outputs": [],
   "source": [
    "from utils import marxpars_from_asol\n",
    "pars = marxpars_from_asol(asolfile, evt2file)\n",
    "pars['OutputDir'] = 'COUP'\n",
    "pars['SourceType'] = 'USER'\n",
    "pars['UserSourceFile'] = 'pnts.so'\n",
    "pars['UserSourceArgs'] = 'coup.marxin'\n",
    "# We could try to rigorously determine the total flux of the field\n",
    "# but here we just pick a number that will give us a good number of photons.\n",
    "pars['SourceFlux'] = 0.03\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "'''Currently, MARX can only be run from the command line. So we build\n",
    "a command line call from the parameters dictionary and run it via\n",
    "subprocess.call().'''\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER COUP COUP.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ede804f1",
   "metadata": {},
   "source": [
    "In the observation, the brightest sources are piled-up. We don't bother\n",
    "simulating this here, so for the visualization we just set the scaling limits to bring out\n",
    "the fainter details and ignore the bright peaks."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "703a8476",
   "metadata": {},
   "outputs": [],
   "source": [
    "from astropy.visualization import simple_norm\n",
    "import numpy as np\n",
    "from mpl_toolkits.axes_grid1 import ImageGrid\n",
    "import matplotlib.pyplot as plt\n",
    "import pycrates\n",
    "\n",
    "fig = plt.figure(figsize=(12,6))\n",
    "grid = ImageGrid(\n",
    "    fig, 111,  # similar to fig.add_subplot(142).\n",
    "    nrows_ncols=(1, 2), axes_pad=0.4, label_mode=\"L\", share_all=True,\n",
    "    cbar_location=\"top\", cbar_mode=\"single\")\n",
    "for ax, cax, src, title in zip(grid, grid.cbar_axes, \n",
    "                               [evt2file, 'COUP.fits'], \n",
    "                               ['Observation', 'MARX Simulation']):\n",
    "    evt = pycrates.read_file(src)\n",
    "    hist= np.histogram2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                    bins=600, range=[[3900,4500], [3900,4500]])\n",
    "    norm = simple_norm(hist[0], 'log', vmax=300)\n",
    "    im = ax.imshow(hist[0].T, origin='lower', extent=[3900,4500,3900,4500], norm=norm)\n",
    "    out = ax.set_title(title)\n",
    "    cbar = cax.colorbar(im)\n",
    "    cbar.set_label('Counts per bin')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0eb256d5",
   "metadata": {},
   "source": [
    "Image of the observed data (left) and simulation (right). The diagonal line from the center to the top right is the read-out streak from $\\theta^1$ Ori C.\n",
    "                           "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b5591218",
   "metadata": {},
   "outputs": [],
   "source": [
    "from ciao_contrib import runtool as rt\n",
    "\n",
    "rt.dmcopy(\"COUP.fits[EVENTS][bin x=2500:5500:2,y=2500:5500:2]\", \"im.fits\", option=\"image\",\n",
    "           clobber=True)\n",
    "rt.mkpsfmap(\"im.fits\", \"psf.map\", energy=1.4, ecf=0.5, clobber=True)\n",
    "rt.celldetect(\"im.fits\", \"src.fits\", psffile=\"psf.map\", clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "090b2150",
   "metadata": {},
   "outputs": [],
   "source": [
    "from astropy.coordinates import SkyCoord\n",
    "from astropy.io import fits\n",
    "src = Table.read('src.fits')\n",
    "\n",
    "src_co = SkyCoord(src['RA'], src['DEC'], unit='deg')\n",
    "srcin_co = SkyCoord(coup['RAJ2000'], coup['DEJ2000'], unit='deg')\n",
    "idx, d2d, d3d = src_co.match_to_catalog_sky(srcin_co)\n",
    "\n",
    "asol = fits.getheader(asolfile, 1)\n",
    "cen = SkyCoord(asol['RA_NOM'], asol['DEC_NOM'], unit='deg')\n",
    "d = cen.separation(src_co).arcsec\n",
    "\n",
    "fig = plt.figure()\n",
    "ax1 = plt.subplot(111)\n",
    "scat1 = ax1.scatter(d, d2d.arcsec, c=np.log10(src['NET_COUNTS']), lw=1)\n",
    "ax1.set_xlabel('distance from aimpoint [arcsec]')\n",
    "ax1.set_ylabel('coordinate error [arcsec]')\n",
    "ax1.set_xlim([0, 350])\n",
    "ax1.set_ylim([0, 2])\n",
    "cbar1 = fig.colorbar(scat1, ax=ax1)\n",
    "cbar1.set_label('log(net counts per source)')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5ecb59d2",
   "metadata": {},
   "source": [
    "Apart from a clump close to the aimpoint (where sources in the ONC are so close to each other that they can easily be confused), the distribution of coordinate errors spreads out with increasing distance, i.e. size of the PSF."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "45862b93",
   "metadata": {},
   "source": [
    "## Simulations with an IMAGE source\n",
    "The `SourceType=IMAGE` in marx is a strange beast that behaves in ways that users might find surprising. When using this source type, marx will read in an image file and use the pixel values as relative probabilities for generating photons across the image.\n",
    "\n",
    "Marx _will_ read the WCS in the image header, but _only_ use the absolute value for the pixel size, not the orientation or position. The center of the image is always supposed to be at the nominal pointing position and the image x/y axes are always aligned with the sky coordinate system in marx."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32d3182a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Turn the downloaded event file into an image\n",
    "from ciao_contrib import runtool as rt\n",
    "rt.dmcopy.punlearn()\n",
    "rt.dmcopy(evt2file + '[bin x=3900:4500:1,y=3900:4500:1]', '3744_image.fits', clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b7cf658e",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Are using astropy for the coordinate transforms, just because I know it better and can type it faster\n",
    "# than the equivalent packages that are part of CIAO\n",
    "from astropy.wcs import WCS\n",
    "from astropy.io import fits\n",
    "\n",
    "# Fortunately, the chandra X/Y axes are already aligned with the axes that marx uses,\n",
    "# so no image rotation is needed here.\n",
    "with fits.open('3744_image.fits') as hdus:\n",
    "    wcs = WCS(hdus[0].header, fix=False)\n",
    "    shape = hdus[0].data.shape\n",
    "center = wcs.pixel_to_world(shape[0]/2, shape[1]/2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1b159c82",
   "metadata": {},
   "outputs": [],
   "source": [
    "'''MARX simulation with an IMAGE source \n",
    "'''\n",
    "pars['SourceFlux'] = 0.003 # speed up during experimentation\n",
    "\n",
    "pars['SourceType'] = 'IMAGE'\n",
    "pars['S-ImageFile'] = '3744_image.fits'\n",
    "pars['OutputDir'] = 'COUP_image'\n",
    "pars['SourceRA'] = center.ra.deg\n",
    "pars['SourceDEC'] = center.dec.deg\n",
    "pars['DitherModel'] = 'INTERNAL'\n",
    "\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER COUP_image COUP_image_evt2.fits',\n",
    "                      shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "69feb448",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Let's turn the simulated data into an image, too, to make it easier to \n",
    "# display in WCS instead of in detector coordinates\n",
    "rt.dmcopy('COUP_image_evt2.fits[bin x=3900:4500:1,y=3900:4500:1]', 'COUP_image.fits', clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0cad1bd5",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig = plt.figure(figsize=(12,6))\n",
    "for i, f in enumerate(['3744_image.fits', 'COUP_image.fits'], start=1):\n",
    "    with fits.open(f) as hdus:\n",
    "        wcs = WCS(hdus[0].header, fix=False)\n",
    "        data = hdus[0].data\n",
    "    norm = simple_norm(data, 'log', vmax=300)\n",
    "    ax = fig.add_subplot(1, 2, i, projection=wcs)\n",
    "    ax.imshow(data, norm=norm, origin='lower')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "54af6860",
   "metadata": {},
   "source": [
    "## Regular Grid (ACIS)\n",
    "In this example we place a radial grid of sources on the sky. Each source\n",
    "emits an equal number of photons (exactly, no Poisson statistics) so that\n",
    "we can compare the accuracy of the position we recover. Note that the\n",
    "*detected* number of photons will be smaller for off-axis photons because\n",
    "of vignetting!\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7cbb1871",
   "metadata": {},
   "outputs": [],
   "source": [
    "ccode='''\n",
    "#include <stdio.h>\n",
    "#include <math.h>\n",
    "#include \"user.h\"\n",
    "\n",
    "static double Source_CosX;\n",
    "static double Source_CosY;\n",
    "static double Source_CosZ;\n",
    "\n",
    "int user_open_source (char **argv, int argc, double area,\n",
    "\t\t      double cosx, double cosy, double cosz)\n",
    "{\n",
    "   return 0;\n",
    "}\n",
    "\n",
    "void user_close_source (void)\n",
    "{\n",
    "}\n",
    "\n",
    "static double To_Radians = (M_PI / 180.0 / 3600.0);\n",
    "#define ARC_SECONDS_PER_CELL 50\n",
    "#define ANGULAR_STEPS 16\n",
    "\n",
    "int user_create_ray (double *delta_t, double *energy,\n",
    "\t\t     double *cosx, double *cosy, double *cosz)\n",
    "{\n",
    "   static int last_i = 0;\n",
    "   static int last_j = 0;\n",
    "   double theta, phi;\n",
    "   double cos_theta, sin_theta;\n",
    "\n",
    "   if (last_j == ANGULAR_STEPS){\n",
    "        last_j = 0;\n",
    "        last_i++;\n",
    "   }\n",
    "   if (last_i == 20) last_i = 0;\n",
    "\n",
    "   theta = To_Radians * last_i * ARC_SECONDS_PER_CELL;\n",
    "   phi = (10. /180 * M_PI) + last_j * 2 * M_PI / ANGULAR_STEPS;\n",
    "\n",
    "   sin_theta = sin(theta);\n",
    "\n",
    "   *cosx = -cos (theta);\n",
    "   *cosy = sin_theta * cos (phi);\n",
    "   *cosz = sin_theta * sin (phi);\n",
    "\n",
    "   *delta_t = -1.0;\n",
    "   *energy = -1.0;\n",
    "\n",
    "   if (last_i ==0){\n",
    "     last_i++;\n",
    "        }\n",
    "   else {\n",
    "     last_j++;\n",
    "        }\n",
    "\n",
    "   return 0;\n",
    "}\n",
    "\n",
    "int main (int a, char **b)\n",
    "{\n",
    "   (void) a;\n",
    "   (void) b;\n",
    "   return 1;\n",
    "}'''\n",
    "with open('radialgrid.c', 'w') as f:\n",
    "    f.write(ccode)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "812a44ee",
   "metadata": {},
   "outputs": [],
   "source": [
    "out = subprocess.run(['gcc', '-lm',\n",
    "                      '-shared', 'radialgrid.c', '-o', 'radialgrid.so'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4df9133c",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars = {'SourceType': 'USER', 'OutputDir': 'points',\n",
    "        'GratingType': 'NONE','SourceRA': 90., 'SourceDEC': 0.,\n",
    "        'RA_Nom': 90., 'Dec_Nom': 0, 'Roll_Nom': 0,\n",
    "        'DetectorType': 'ACIS-I',\n",
    "        'UserSourceFile': 'radialgrid.so',\n",
    "        'NumRays': -100000, 'ExposureTime': 0}\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "'''Currently, MARX can only be run from the command line. So we build\n",
    "a command line call from the parameters dictionary and run it via\n",
    "subprocess.call().'''\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER points points.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "d6f3349a",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(6,6))\n",
    "\n",
    "evt = pycrates.read_file('points.fits')\n",
    "hist= np.histogram2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                bins=600, range=[[4097-1200,4097+1200], [4097-1200,4097+1200]])\n",
    "norm = simple_norm(hist[0], 'log') #, vmax=300)\n",
    "im = ax.imshow(hist[0].T, origin='lower', extent=[4097-1200,4097+1200,4097-1200,4097+1200], norm=norm)\n",
    "cbar = plt.colorbar(im)\n",
    "cbar.set_label('Counts per bin')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "967c68a1",
   "metadata": {},
   "source": [
    "Image of the simulation. The size of the PSF increases further away from the aimpoint.\n",
    "                       "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "6aad0a16",
   "metadata": {},
   "outputs": [],
   "source": [
    "rt.dmcopy(\"points.fits[EVENTS][bin x=3000:5100:1,y=3000:5100:1]\", \"im.fits\", option=\"image\",\n",
    "           clobber=True)\n",
    "rt.mkpsfmap(\"im.fits\", \"psf.map\", energy=1.4, ecf=0.5, clobber=True)\n",
    "rt.celldetect(\"im.fits\", \"src.fits\", psffile=\"psf.map\", clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a2d551b0",
   "metadata": {},
   "outputs": [],
   "source": [
    "src = Table.read('src.fits')\n",
    "# Find distance from input position.\n",
    "src['RA_INPUT'] = src['RA'] - (src['RA'] // (360./16.)) * (360./16.) - 10.\n",
    "# Problem: Might expect source at 1.0,\n",
    "# but measure at 0.99. In this case distance to next lower source\n",
    "# is 0.99. Thus shift input by 0.005 (about 50 arcsec / 2)\n",
    "# before integer devision\n",
    "src['DEC_INPUT'] = src['DEC'] - ((0.005 + src['DEC']) // (50./3600.)) * (50./3600.)\n",
    "\n",
    "cen = SkyCoord(90., 0, unit='deg')\n",
    "det = SkyCoord(src['RA'], src['DEC'], unit='deg')\n",
    "d = cen.separation(det).arcsec\n",
    "d_err = np.mod(d + 10, 50.) - 10\n",
    "\n",
    "ang = cen.position_angle(det).degree\n",
    "# Subtract offset that we placed in the C code to avoid 0./360. ambiguity\n",
    "# Step width is 360./16 = 22.5 deg\n",
    "# Offset is 10 deg. Complement we find here is 12.5 deg.\n",
    "ang = ang - 12.5\n",
    "\n",
    "ang_err = np.mod(ang + 2, 360. / 16.) - 2\n",
    "ind = d > 10\n",
    "\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))\n",
    "scat1 = ax1.scatter(d, d_err, c=src['NET_COUNTS'], lw=1)\n",
    "ax1.set_xlabel('distance [arcsec]')\n",
    "ax1.set_ylabel('distance error [arcsec]')\n",
    "ax1.set_xlim([-10, 620])\n",
    "ax1.set_ylim([-1, 0.5])\n",
    "scat2 = ax2.scatter(ang, ang_err, c=src['NET_COUNTS'], lw=1)\n",
    "ax2.set_xlabel('pos ang [deg]')\n",
    "ax2.set_ylabel('pos ang error [deg]')\n",
    "ax2.set_xlim([-5, 350])\n",
    "ax2.set_ylim([-0.3, 0.3])\n",
    "cbar2 = fig.colorbar(scat2, ax=ax2)\n",
    "cbar2.set_label('net counts per source')\n",
    "fig.tight_layout()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1e6c6659",
   "metadata": {},
   "source": [
    "*left*: The error in the position (measured radially to the optical axis) increases with the distance to the optical axis. One part of this is just that the effective area and thus the number of counts decreases. There is also a systematic trend where sources at larger off-axis angle are systematically fitted too close to the center. Further investigation is necessary to check if this is a problem of marx or the CIAO tool celldetect. In any case, the typical offset is below 0.2 arcsec, which is less than half a pixel in ACIS. *right*: Difference in position angle between input and fit.\n",
    "\n",
    "The input position is typically recovered to much better than one pixel for sources with a few hundred counts. There is a small systematic trend that needs to be studied further."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2bb02859",
   "metadata": {},
   "source": [
    "## Regular grid (HRC)\n",
    "Same as above, but with HRC-I as a detector.\n",
    "\n",
    "The field-of-view for the HRC-I is larger for than for ACIS-I, but the PSF becomes\n",
    "very large at large off-axis angles and thus the positional uncertainty\n",
    "will be so large that a comparison to marx is no longer helpful to test\n",
    "the accuracy of the marx simulations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b860af8f",
   "metadata": {},
   "outputs": [],
   "source": [
    "pars['DetectorType'] = 'HRC-I'\n",
    "marxcall = ['marx'] + ['{0}={1}'.format(k, v) for k, v in pars.items()]\n",
    "marxcall = ' '.join(marxcall)\n",
    "\n",
    "out = subprocess.run(marxcall, shell=True, capture_output=True)\n",
    "out2 = subprocess.run('marx2fits --pixadj=EDSER points points.fits', shell=True, capture_output=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84dcffac",
   "metadata": {},
   "outputs": [],
   "source": [
    "fig, ax = plt.subplots(figsize=(6,6))\n",
    "\n",
    "evt = pycrates.read_file('points.fits')\n",
    "hist= np.histogram2d(evt.get_column('X').values, evt.get_column('Y').values, \n",
    "                bins=600, range=[[16292-4000,16292+4000], [16392-4000,16392+4000]])\n",
    "norm = simple_norm(hist[0], 'log') #, vmax=300)\n",
    "im = ax.imshow(hist[0].T, origin='lower', extent=[16292-4000,16292+4000,16392-4000,16392+4000], norm=norm)\n",
    "cbar = plt.colorbar(im)\n",
    "cbar.set_label('Counts per bin')"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1cf2c1d4",
   "metadata": {},
   "source": [
    "Image of the simulation. The size of the PSF increases further away from the aimpoint.\n",
    "                  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b8a44142",
   "metadata": {},
   "outputs": [],
   "source": [
    "rt.dmcopy(\"points.fits[EVENTS][bin x=8500:24500:2,y=8500:24500:2]\", \"im.fits\", option=\"image\",\n",
    "           clobber=True)\n",
    "rt.mkpsfmap(\"im.fits\", \"psf.map\", energy=1.4, ecf=0.5, clobber=True)\n",
    "rt.celldetect(\"im.fits\", \"src.fits\", psffile=\"psf.map\", clobber=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "55c41453",
   "metadata": {},
   "outputs": [],
   "source": [
    "src = Table.read('src.fits')\n",
    "src['RA_INPUT'] = src['RA'] - (src['RA'] // (360./16.)) * (360./16.) - 10.\n",
    "src['DEC_INPUT'] = src['DEC'] - ((0.005 + src['DEC']) // (50./3600.)) * (50./3600.)\n",
    "\n",
    "cen = SkyCoord(90., 0, unit='deg')\n",
    "det = SkyCoord(src['RA'], src['DEC'], unit='deg')\n",
    "d = cen.separation(det).arcsec\n",
    "d_err = np.mod(d + 10, 50.) - 10\n",
    "\n",
    "ang = cen.position_angle(det).degree\n",
    "# Subtract offset that we placed in the C code to avoid 0./360. ambiguity\n",
    "# Step width is 360./16 = 22.5 deg\n",
    "# Offset is 10 deg. Complement we find here is 12.5 deg.\n",
    "ang = ang - 12.5\n",
    "\n",
    "ang_err = np.mod(ang + 2, 360. / 16.) - 2\n",
    "ind = d > 10\n",
    "\n",
    "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))\n",
    "scat1 = ax1.scatter(d, d_err, c=src['NET_COUNTS'], lw=1)\n",
    "ax1.set_xlabel('distance [arcsec]')\n",
    "ax1.set_ylabel('distance error [arcsec]')\n",
    "ax1.set_xlim([-10, 620])\n",
    "ax1.set_ylim([-1, 0.5])\n",
    "scat2 = ax2.scatter(ang, ang_err, c=src['NET_COUNTS'], lw=1)\n",
    "ax2.set_xlabel('pos ang [deg]')\n",
    "ax2.set_ylabel('pos ang error [deg]')\n",
    "ax2.set_xlim([-5, 350])\n",
    "ax2.set_ylim([-0.3, 0.3])\n",
    "cbar2 = fig.colorbar(scat2, ax=ax2)\n",
    "cbar2.set_label('net counts per source')\n",
    "fig.tight_layout()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f9defed1",
   "metadata": {},
   "source": [
    "See previous example. The same trends are visible with a slightly larger scatter.\n",
    "\n",
    "In the central few arcmin the input position is typically recovered to better than 0.2 pixels for sources with a few hundred counts."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ciao-4.18.b2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.12"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
